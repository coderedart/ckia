#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen 0.69.2 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SK_C_INCREMENT: u32 = 0;
pub const FONTMETRICS_FLAGS_UNDERLINE_THICKNESS_IS_VALID: u32 = 1;
pub const FONTMETRICS_FLAGS_UNDERLINE_POSITION_IS_VALID: u32 = 2;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_refcnt_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_nvrefcnt_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_flattenable_t {
    _unused: [u8; 0],
}
pub type sk_color_t = u32;
pub type sk_pmcolor_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_color4f_t {
    pub fR: f32,
    pub fG: f32,
    pub fB: f32,
    pub fA: f32,
}
#[test]
fn bindgen_test_layout_sk_color4f_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_color4f_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_color4f_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_color4f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_color4f_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_color4f_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_color4f_t),
            "::",
            stringify!(fR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fG) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_color4f_t),
            "::",
            stringify!(fG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fB) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_color4f_t),
            "::",
            stringify!(fB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_color4f_t),
            "::",
            stringify!(fA)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_colortype_t {
    UNKNOWN_SK_COLORTYPE = 0,
    ALPHA_8_SK_COLORTYPE = 1,
    RGB_565_SK_COLORTYPE = 2,
    ARGB_4444_SK_COLORTYPE = 3,
    RGBA_8888_SK_COLORTYPE = 4,
    RGB_888X_SK_COLORTYPE = 5,
    BGRA_8888_SK_COLORTYPE = 6,
    RGBA_1010102_SK_COLORTYPE = 7,
    BGRA_1010102_SK_COLORTYPE = 8,
    RGB_101010X_SK_COLORTYPE = 9,
    BGR_101010X_SK_COLORTYPE = 10,
    BGR_101010X_XR_SK_COLORTYPE = 11,
    RGBA_10X6_SK_COLORTYPE = 12,
    GRAY_8_SK_COLORTYPE = 13,
    RGBA_F16_NORM_SK_COLORTYPE = 14,
    RGBA_F16_SK_COLORTYPE = 15,
    RGBA_F32_SK_COLORTYPE = 16,
    R8G8_UNORM_SK_COLORTYPE = 17,
    A16_FLOAT_SK_COLORTYPE = 18,
    R16G16_FLOAT_SK_COLORTYPE = 19,
    A16_UNORM_SK_COLORTYPE = 20,
    R16G16_UNORM_SK_COLORTYPE = 21,
    R16G16B16A16_UNORM_SK_COLORTYPE = 22,
    SRGBA_8888_SK_COLORTYPE = 23,
    R8_UNORM_SK_COLORTYPE = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_alphatype_t {
    UNKNOWN_SK_ALPHATYPE = 0,
    OPAQUE_SK_ALPHATYPE = 1,
    PREMUL_SK_ALPHATYPE = 2,
    UNPREMUL_SK_ALPHATYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_pixelgeometry_t {
    UNKNOWN_SK_PIXELGEOMETRY = 0,
    RGB_H_SK_PIXELGEOMETRY = 1,
    BGR_H_SK_PIXELGEOMETRY = 2,
    RGB_V_SK_PIXELGEOMETRY = 3,
    BGR_V_SK_PIXELGEOMETRY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_surfaceprops_flags_t {
    NONE_SK_SURFACE_PROPS_FLAGS = 0,
    USE_DEVICE_INDEPENDENT_FONTS_SK_SURFACE_PROPS_FLAGS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_surfaceprops_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_point_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_sk_point_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_point_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_point_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_point_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_point_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point_t),
            "::",
            stringify!(y)
        )
    );
}
pub type sk_vector_t = sk_point_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_irect_t {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[test]
fn bindgen_test_layout_sk_irect_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_irect_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_irect_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_irect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_irect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_irect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_irect_t),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_rect_t {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout_sk_rect_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_rect_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_rect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rect_t),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_matrix_t {
    pub scaleX: f32,
    pub skewX: f32,
    pub transX: f32,
    pub skewY: f32,
    pub scaleY: f32,
    pub transY: f32,
    pub persp0: f32,
    pub persp1: f32,
    pub persp2: f32,
}
#[test]
fn bindgen_test_layout_sk_matrix_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_matrix_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_matrix_t>(),
        36usize,
        concat!("Size of: ", stringify!(sk_matrix_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_matrix_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_matrix_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaleX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(scaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skewX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(skewX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(transX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skewY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(skewY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaleY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(scaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(transY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persp0) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(persp0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persp1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(persp1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persp2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix_t),
            "::",
            stringify!(persp2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_matrix44_t {
    pub m00: f32,
    pub m01: f32,
    pub m02: f32,
    pub m03: f32,
    pub m10: f32,
    pub m11: f32,
    pub m12: f32,
    pub m13: f32,
    pub m20: f32,
    pub m21: f32,
    pub m22: f32,
    pub m23: f32,
    pub m30: f32,
    pub m31: f32,
    pub m32: f32,
    pub m33: f32,
}
#[test]
fn bindgen_test_layout_sk_matrix44_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_matrix44_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_matrix44_t>(),
        64usize,
        concat!("Size of: ", stringify!(sk_matrix44_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_matrix44_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_matrix44_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m00) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m00)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m01) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m01)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m02) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m02)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m03) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m03)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m10) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m11) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m12) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m13) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m20) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m20)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m21) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m21)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m22) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m22)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m23) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m23)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m30) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m30)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m31) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m31)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m32) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m33) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_matrix44_t),
            "::",
            stringify!(m33)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_nodraw_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_nway_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_overdraw_canvas_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_drawable_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_image_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_maskfilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_paint_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_font_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_picture_recorder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_shader_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_surface_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_region_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_region_iterator_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_region_cliperator_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_region_spanerator_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_blendmode_t {
    CLEAR_SK_BLENDMODE = 0,
    SRC_SK_BLENDMODE = 1,
    DST_SK_BLENDMODE = 2,
    SRCOVER_SK_BLENDMODE = 3,
    DSTOVER_SK_BLENDMODE = 4,
    SRCIN_SK_BLENDMODE = 5,
    DSTIN_SK_BLENDMODE = 6,
    SRCOUT_SK_BLENDMODE = 7,
    DSTOUT_SK_BLENDMODE = 8,
    SRCATOP_SK_BLENDMODE = 9,
    DSTATOP_SK_BLENDMODE = 10,
    XOR_SK_BLENDMODE = 11,
    PLUS_SK_BLENDMODE = 12,
    MODULATE_SK_BLENDMODE = 13,
    SCREEN_SK_BLENDMODE = 14,
    OVERLAY_SK_BLENDMODE = 15,
    DARKEN_SK_BLENDMODE = 16,
    LIGHTEN_SK_BLENDMODE = 17,
    COLORDODGE_SK_BLENDMODE = 18,
    COLORBURN_SK_BLENDMODE = 19,
    HARDLIGHT_SK_BLENDMODE = 20,
    SOFTLIGHT_SK_BLENDMODE = 21,
    DIFFERENCE_SK_BLENDMODE = 22,
    EXCLUSION_SK_BLENDMODE = 23,
    MULTIPLY_SK_BLENDMODE = 24,
    HUE_SK_BLENDMODE = 25,
    SATURATION_SK_BLENDMODE = 26,
    COLOR_SK_BLENDMODE = 27,
    LUMINOSITY_SK_BLENDMODE = 28,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_point3_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sk_point3_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_point3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_point3_t>(),
        12usize,
        concat!("Size of: ", stringify!(sk_point3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_point3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_point3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_point3_t),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_ipoint_t {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_sk_ipoint_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_ipoint_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_ipoint_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_ipoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_ipoint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_ipoint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_ipoint_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_ipoint_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_size_t {
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_sk_size_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_size_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_size_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_size_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_size_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_size_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_size_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_isize_t {
    pub w: i32,
    pub h: i32,
}
#[test]
fn bindgen_test_layout_sk_isize_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_isize_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_isize_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_isize_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_isize_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_isize_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_isize_t),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_isize_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontmetrics_t {
    pub fFlags: u32,
    pub fTop: f32,
    pub fAscent: f32,
    pub fDescent: f32,
    pub fBottom: f32,
    pub fLeading: f32,
    pub fAvgCharWidth: f32,
    pub fMaxCharWidth: f32,
    pub fXMin: f32,
    pub fXMax: f32,
    pub fXHeight: f32,
    pub fCapHeight: f32,
    pub fUnderlineThickness: f32,
    pub fUnderlinePosition: f32,
    pub fStrikeoutThickness: f32,
    pub fStrikeoutPosition: f32,
}
#[test]
fn bindgen_test_layout_sk_fontmetrics_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_fontmetrics_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_fontmetrics_t>(),
        64usize,
        concat!("Size of: ", stringify!(sk_fontmetrics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_fontmetrics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_fontmetrics_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAscent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fAscent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDescent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fDescent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fBottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fLeading) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fLeading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAvgCharWidth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fAvgCharWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMaxCharWidth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fMaxCharWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXMin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXMax) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXHeight) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fXHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCapHeight) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fCapHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fUnderlineThickness) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fUnderlineThickness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fUnderlinePosition) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fUnderlinePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fStrikeoutThickness) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fStrikeoutThickness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fStrikeoutPosition) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_fontmetrics_t),
            "::",
            stringify!(fStrikeoutPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_string_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_bitmap_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pixmap_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorfilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_imagefilter_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_typeface_t {
    _unused: [u8; 0],
}
pub type sk_font_table_tag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontmgr_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontstyle_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontstyleset_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_fontarguments_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_filestream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_asset_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_memorystream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_stream_streamrewindable_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_filestream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_wstream_dynamicmemorystream_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_document_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_point_mode_t {
    POINTS_SK_POINT_MODE = 0,
    LINES_SK_POINT_MODE = 1,
    POLYGON_SK_POINT_MODE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_text_align_t {
    LEFT_SK_TEXT_ALIGN = 0,
    CENTER_SK_TEXT_ALIGN = 1,
    RIGHT_SK_TEXT_ALIGN = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_text_encoding_t {
    UTF8_SK_TEXT_ENCODING = 0,
    UTF16_SK_TEXT_ENCODING = 1,
    UTF32_SK_TEXT_ENCODING = 2,
    GLYPH_ID_SK_TEXT_ENCODING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_filltype_t {
    WINDING_SK_PATH_FILLTYPE = 0,
    EVENODD_SK_PATH_FILLTYPE = 1,
    INVERSE_WINDING_SK_PATH_FILLTYPE = 2,
    INVERSE_EVENODD_SK_PATH_FILLTYPE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_font_style_slant_t {
    UPRIGHT_SK_FONT_STYLE_SLANT = 0,
    ITALIC_SK_FONT_STYLE_SLANT = 1,
    OBLIQUE_SK_FONT_STYLE_SLANT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_color_channel_t {
    R_SK_COLOR_CHANNEL = 0,
    G_SK_COLOR_CHANNEL = 1,
    B_SK_COLOR_CHANNEL = 2,
    A_SK_COLOR_CHANNEL = 3,
}
#[repr(u32)]
#[doc = "The logical operations that can be performed when combining two regions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_region_op_t {
    #[doc = "!< subtract the op region from the first region"]
    DIFFERENCE_SK_REGION_OP = 0,
    #[doc = "!< intersect the two regions"]
    INTERSECT_SK_REGION_OP = 1,
    #[doc = "!< union (inclusive-or) the two regions"]
    UNION_SK_REGION_OP = 2,
    #[doc = "!< exclusive-or the two regions"]
    XOR_SK_REGION_OP = 3,
    #[doc = "!< subtract the first region from the op region"]
    REVERSE_DIFFERENCE_SK_REGION_OP = 4,
    #[doc = "!< replace the dst region with the op region"]
    REPLACE_SK_REGION_OP = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_clipop_t {
    DIFFERENCE_SK_CLIPOP = 0,
    INTERSECT_SK_CLIPOP = 1,
}
#[repr(u32)]
#[doc = "  Enum describing format of encoded data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_encoded_image_format_t {
    BMP_SK_ENCODED_FORMAT = 0,
    GIF_SK_ENCODED_FORMAT = 1,
    ICO_SK_ENCODED_FORMAT = 2,
    JPEG_SK_ENCODED_FORMAT = 3,
    PNG_SK_ENCODED_FORMAT = 4,
    WBMP_SK_ENCODED_FORMAT = 5,
    WEBP_SK_ENCODED_FORMAT = 6,
    PKM_SK_ENCODED_FORMAT = 7,
    KTX_SK_ENCODED_FORMAT = 8,
    ASTC_SK_ENCODED_FORMAT = 9,
    DNG_SK_ENCODED_FORMAT = 10,
    HEIF_SK_ENCODED_FORMAT = 11,
    AVIF_SK_ENCODED_FORMAT = 12,
    JPEGXL_SK_ENCODED_FORMAT = 13,
}
impl sk_encodedorigin_t {
    pub const DEFAULT_SK_ENCODED_ORIGIN: sk_encodedorigin_t =
        sk_encodedorigin_t::TOP_LEFT_SK_ENCODED_ORIGIN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_encodedorigin_t {
    TOP_LEFT_SK_ENCODED_ORIGIN = 1,
    TOP_RIGHT_SK_ENCODED_ORIGIN = 2,
    BOTTOM_RIGHT_SK_ENCODED_ORIGIN = 3,
    BOTTOM_LEFT_SK_ENCODED_ORIGIN = 4,
    LEFT_TOP_SK_ENCODED_ORIGIN = 5,
    RIGHT_TOP_SK_ENCODED_ORIGIN = 6,
    RIGHT_BOTTOM_SK_ENCODED_ORIGIN = 7,
    LEFT_BOTTOM_SK_ENCODED_ORIGIN = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_codec_result_t {
    SUCCESS_SK_CODEC_RESULT = 0,
    INCOMPLETE_INPUT_SK_CODEC_RESULT = 1,
    ERROR_IN_INPUT_SK_CODEC_RESULT = 2,
    INVALID_CONVERSION_SK_CODEC_RESULT = 3,
    INVALID_SCALE_SK_CODEC_RESULT = 4,
    INVALID_PARAMETERS_SK_CODEC_RESULT = 5,
    INVALID_INPUT_SK_CODEC_RESULT = 6,
    COULD_NOT_REWIND_SK_CODEC_RESULT = 7,
    INTERNAL_ERROR_SK_CODEC_RESULT = 8,
    UNIMPLEMENTED_SK_CODEC_RESULT = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_codec_zero_initialized_t {
    YES_SK_CODEC_ZERO_INITIALIZED = 0,
    NO_SK_CODEC_ZERO_INITIALIZED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_options_t {
    pub fZeroInitialized: sk_codec_zero_initialized_t,
    pub fSubset: *mut sk_irect_t,
    pub fFrameIndex: ::std::os::raw::c_int,
    pub fPriorFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sk_codec_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_codec_options_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_codec_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_codec_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_codec_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_codec_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fZeroInitialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fZeroInitialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSubset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fSubset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFrameIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fFrameIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPriorFrame) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_options_t),
            "::",
            stringify!(fPriorFrame)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_codec_scanline_order_t {
    TOP_DOWN_SK_CODEC_SCANLINE_ORDER = 0,
    BOTTOM_UP_SK_CODEC_SCANLINE_ORDER = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_verb_t {
    MOVE_SK_PATH_VERB = 0,
    LINE_SK_PATH_VERB = 1,
    QUAD_SK_PATH_VERB = 2,
    CONIC_SK_PATH_VERB = 3,
    CUBIC_SK_PATH_VERB = 4,
    CLOSE_SK_PATH_VERB = 5,
    DONE_SK_PATH_VERB = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_iterator_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_rawiterator_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_add_mode_t {
    APPEND_SK_PATH_ADD_MODE = 0,
    EXTEND_SK_PATH_ADD_MODE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_segment_mask_t {
    LINE_SK_PATH_SEGMENT_MASK = 1,
    QUAD_SK_PATH_SEGMENT_MASK = 2,
    CONIC_SK_PATH_SEGMENT_MASK = 4,
    CUBIC_SK_PATH_SEGMENT_MASK = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_effect_1d_style_t {
    TRANSLATE_SK_PATH_EFFECT_1D_STYLE = 0,
    ROTATE_SK_PATH_EFFECT_1D_STYLE = 1,
    MORPH_SK_PATH_EFFECT_1D_STYLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_effect_trim_mode_t {
    NORMAL_SK_PATH_EFFECT_TRIM_MODE = 0,
    INVERTED_SK_PATH_EFFECT_TRIM_MODE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_path_effect_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_stroke_cap_t {
    BUTT_SK_STROKE_CAP = 0,
    ROUND_SK_STROKE_CAP = 1,
    SQUARE_SK_STROKE_CAP = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_stroke_join_t {
    MITER_SK_STROKE_JOIN = 0,
    ROUND_SK_STROKE_JOIN = 1,
    BEVEL_SK_STROKE_JOIN = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_shader_tilemode_t {
    CLAMP_SK_SHADER_TILEMODE = 0,
    REPEAT_SK_SHADER_TILEMODE = 1,
    MIRROR_SK_SHADER_TILEMODE = 2,
    DECAL_SK_SHADER_TILEMODE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_blurstyle_t {
    #[doc = "!< fuzzy inside and outside"]
    NORMAL_SK_BLUR_STYLE = 0,
    #[doc = "!< solid inside, fuzzy outside"]
    SOLID_SK_BLUR_STYLE = 1,
    #[doc = "!< nothing inside, fuzzy outside"]
    OUTER_SK_BLUR_STYLE = 2,
    #[doc = "!< fuzzy inside, nothing outside"]
    INNER_SK_BLUR_STYLE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_direction_t {
    CW_SK_PATH_DIRECTION = 0,
    CCW_SK_PATH_DIRECTION = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_path_arc_size_t {
    SMALL_SK_PATH_ARC_SIZE = 0,
    LARGE_SK_PATH_ARC_SIZE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_paint_style_t {
    FILL_SK_PAINT_STYLE = 0,
    STROKE_SK_PAINT_STYLE = 1,
    STROKE_AND_FILL_SK_PAINT_STYLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_font_hinting_t {
    NONE_SK_FONT_HINTING = 0,
    SLIGHT_SK_FONT_HINTING = 1,
    NORMAL_SK_FONT_HINTING = 2,
    FULL_SK_FONT_HINTING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_font_edging_t {
    ALIAS_SK_FONT_EDGING = 0,
    ANTIALIAS_SK_FONT_EDGING = 1,
    SUBPIXEL_ANTIALIAS_SK_FONT_EDGING = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pixelref_factory_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum gr_surfaceorigin_t {
    TOP_LEFT_GR_SURFACE_ORIGIN = 0,
    BOTTOM_LEFT_GR_SURFACE_ORIGIN = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_context_options_t {
    pub fAvoidStencilBuffers: bool,
    pub fRuntimeProgramCacheSize: ::std::os::raw::c_int,
    pub fGlyphCacheTextureMaximumBytes: usize,
    pub fAllowPathMaskCaching: bool,
    pub fDoManualMipmapping: bool,
    pub fBufferMapThreshold: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gr_context_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_context_options_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_context_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(gr_context_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_context_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_context_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAvoidStencilBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fAvoidStencilBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRuntimeProgramCacheSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fRuntimeProgramCacheSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).fGlyphCacheTextureMaximumBytes) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fGlyphCacheTextureMaximumBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAllowPathMaskCaching) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fAllowPathMaskCaching)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDoManualMipmapping) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fDoManualMipmapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBufferMapThreshold) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_context_options_t),
            "::",
            stringify!(fBufferMapThreshold)
        )
    );
}
pub type gr_backendobject_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_backendrendertarget_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_backendtexture_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_direct_context_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_recording_context_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum gr_backend_t {
    OPENGL_GR_BACKEND = 0,
    VULKAN_GR_BACKEND = 1,
    METAL_GR_BACKEND = 2,
    DIRECT3D_GR_BACKEND = 3,
    DAWN_GR_BACKEND = 4,
}
pub type gr_backendcontext_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_glinterface_t {
    _unused: [u8; 0],
}
pub type gr_gl_func_ptr = ::std::option::Option<unsafe extern "C" fn()>;
pub type gr_gl_get_proc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> gr_gl_func_ptr,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_gl_textureinfo_t {
    pub fTarget: ::std::os::raw::c_uint,
    pub fID: ::std::os::raw::c_uint,
    pub fFormat: ::std::os::raw::c_uint,
    pub fProtected: bool,
}
#[test]
fn bindgen_test_layout_gr_gl_textureinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_gl_textureinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_gl_textureinfo_t>(),
        16usize,
        concat!("Size of: ", stringify!(gr_gl_textureinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_gl_textureinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gr_gl_textureinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTarget) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_textureinfo_t),
            "::",
            stringify!(fProtected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_gl_framebufferinfo_t {
    pub fFBOID: ::std::os::raw::c_uint,
    pub fFormat: ::std::os::raw::c_uint,
    pub fProtected: bool,
}
#[test]
fn bindgen_test_layout_gr_gl_framebufferinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_gl_framebufferinfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_gl_framebufferinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(gr_gl_framebufferinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_gl_framebufferinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gr_gl_framebufferinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFBOID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_framebufferinfo_t),
            "::",
            stringify!(fFBOID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_framebufferinfo_t),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_gl_framebufferinfo_t),
            "::",
            stringify!(fProtected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_instance_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vkinterface_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_physical_device_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_physical_device_features_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_physical_device_features_2_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_device_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vk_queue_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_extensions_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_memory_allocator_t {
    _unused: [u8; 0],
}
pub type gr_vk_func_ptr = ::std::option::Option<unsafe extern "C" fn()>;
pub type gr_vk_get_proc = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        instance: *mut vk_instance_t,
        device: *mut vk_device_t,
    ) -> gr_vk_func_ptr,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_backendcontext_t {
    pub fInstance: *mut vk_instance_t,
    pub fPhysicalDevice: *mut vk_physical_device_t,
    pub fDevice: *mut vk_device_t,
    pub fQueue: *mut vk_queue_t,
    pub fGraphicsQueueIndex: u32,
    pub fMinAPIVersion: u32,
    pub fInstanceVersion: u32,
    pub fMaxAPIVersion: u32,
    pub fExtensions: u32,
    pub fVkExtensions: *const gr_vk_extensions_t,
    pub fFeatures: u32,
    pub fDeviceFeatures: *const vk_physical_device_features_t,
    pub fDeviceFeatures2: *const vk_physical_device_features_2_t,
    pub fMemoryAllocator: *mut gr_vk_memory_allocator_t,
    pub fGetProc: gr_vk_get_proc,
    pub fGetProcUserData: *mut ::std::os::raw::c_void,
    pub fOwnsInstanceAndDevice: bool,
    pub fProtectedContext: bool,
}
#[test]
fn bindgen_test_layout_gr_vk_backendcontext_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_vk_backendcontext_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_vk_backendcontext_t>(),
        120usize,
        concat!("Size of: ", stringify!(gr_vk_backendcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_vk_backendcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_vk_backendcontext_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fInstance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fInstance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPhysicalDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fPhysicalDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDevice) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fQueue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fQueue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGraphicsQueueIndex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fGraphicsQueueIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMinAPIVersion) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fMinAPIVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fInstanceVersion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fInstanceVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMaxAPIVersion) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fMaxAPIVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fExtensions) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fExtensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fVkExtensions) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fVkExtensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFeatures) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDeviceFeatures) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fDeviceFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDeviceFeatures2) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fDeviceFeatures2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMemoryAllocator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fMemoryAllocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGetProc) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fGetProc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGetProcUserData) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fGetProcUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOwnsInstanceAndDevice) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fOwnsInstanceAndDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fProtectedContext) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_backendcontext_t),
            "::",
            stringify!(fProtectedContext)
        )
    );
}
pub type gr_vk_backendmemory_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_alloc_t {
    pub fMemory: u64,
    pub fOffset: u64,
    pub fSize: u64,
    pub fFlags: u32,
    pub fBackendMemory: gr_vk_backendmemory_t,
    pub _private_fUsesSystemHeap: bool,
}
#[test]
fn bindgen_test_layout_gr_vk_alloc_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_vk_alloc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_vk_alloc_t>(),
        48usize,
        concat!("Size of: ", stringify!(gr_vk_alloc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_vk_alloc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_vk_alloc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMemory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(fMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(fSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBackendMemory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(fBackendMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._private_fUsesSystemHeap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_alloc_t),
            "::",
            stringify!(_private_fUsesSystemHeap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_ycbcrconversioninfo_t {
    pub fFormat: u32,
    pub fExternalFormat: u64,
    pub fYcbcrModel: u32,
    pub fYcbcrRange: u32,
    pub fXChromaOffset: u32,
    pub fYChromaOffset: u32,
    pub fChromaFilter: u32,
    pub fForceExplicitReconstruction: u32,
    pub fFormatFeatures: u32,
}
#[test]
fn bindgen_test_layout_gr_vk_ycbcrconversioninfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_vk_ycbcrconversioninfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_vk_ycbcrconversioninfo_t>(),
        48usize,
        concat!("Size of: ", stringify!(gr_vk_ycbcrconversioninfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_vk_ycbcrconversioninfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_vk_ycbcrconversioninfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fExternalFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fExternalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYcbcrModel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fYcbcrModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYcbcrRange) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fYcbcrRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXChromaOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fXChromaOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYChromaOffset) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fYChromaOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fChromaFilter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fChromaFilter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).fForceExplicitReconstruction) as usize - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fForceExplicitReconstruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFormatFeatures) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_ycbcrconversioninfo_t),
            "::",
            stringify!(fFormatFeatures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_vk_imageinfo_t {
    pub fImage: u64,
    pub fAlloc: gr_vk_alloc_t,
    pub fImageTiling: u32,
    pub fImageLayout: u32,
    pub fFormat: u32,
    pub fImageUsageFlags: u32,
    pub fSampleCount: u32,
    pub fLevelCount: u32,
    pub fCurrentQueueFamily: u32,
    pub fProtected: bool,
    pub fYcbcrConversionInfo: gr_vk_ycbcrconversioninfo_t,
    pub fSharingMode: u32,
}
#[test]
fn bindgen_test_layout_gr_vk_imageinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_vk_imageinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_vk_imageinfo_t>(),
        144usize,
        concat!("Size of: ", stringify!(gr_vk_imageinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_vk_imageinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_vk_imageinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fImage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fImageTiling) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fImageTiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fImageLayout) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fImageLayout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fImageUsageFlags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fImageUsageFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSampleCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fSampleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fLevelCount) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fLevelCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCurrentQueueFamily) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fCurrentQueueFamily)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fProtected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYcbcrConversionInfo) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fYcbcrConversionInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSharingMode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_vk_imageinfo_t),
            "::",
            stringify!(fSharingMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gr_mtl_textureinfo_t {
    pub fTexture: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gr_mtl_textureinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<gr_mtl_textureinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gr_mtl_textureinfo_t>(),
        8usize,
        concat!("Size of: ", stringify!(gr_mtl_textureinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gr_mtl_textureinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gr_mtl_textureinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTexture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gr_mtl_textureinfo_t),
            "::",
            stringify!(fTexture)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_pathop_t {
    DIFFERENCE_SK_PATHOP = 0,
    INTERSECT_SK_PATHOP = 1,
    UNION_SK_PATHOP = 2,
    XOR_SK_PATHOP = 3,
    REVERSE_DIFFERENCE_SK_PATHOP = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_opbuilder_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_lattice_recttype_t {
    DEFAULT_SK_LATTICE_RECT_TYPE = 0,
    TRANSPARENT_SK_LATTICE_RECT_TYPE = 1,
    FIXED_COLOR_SK_LATTICE_RECT_TYPE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_lattice_t {
    pub fXDivs: *const ::std::os::raw::c_int,
    pub fYDivs: *const ::std::os::raw::c_int,
    pub fRectTypes: *const sk_lattice_recttype_t,
    pub fXCount: ::std::os::raw::c_int,
    pub fYCount: ::std::os::raw::c_int,
    pub fBounds: *const sk_irect_t,
    pub fColors: *const sk_color_t,
}
#[test]
fn bindgen_test_layout_sk_lattice_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_lattice_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_lattice_t>(),
        48usize,
        concat!("Size of: ", stringify!(sk_lattice_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_lattice_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_lattice_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXDivs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fXDivs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYDivs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fYDivs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRectTypes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fRectTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fXCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fXCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fYCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_lattice_t),
            "::",
            stringify!(fColors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pathmeasure_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_pathmeasure_matrixflags_t {
    GET_POSITION_SK_PATHMEASURE_MATRIXFLAGS = 1,
    GET_TANGENT_SK_PATHMEASURE_MATRIXFLAGS = 2,
    GET_POS_AND_TAN_SK_PATHMEASURE_MATRIXFLAGS = 3,
}
pub type sk_bitmap_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_data_release_proc = ::std::option::Option<
    unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_image_raster_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *const ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_image_texture_release_proc =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub type sk_surface_raster_release_proc = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
pub type sk_glyph_path_proc = ::std::option::Option<
    unsafe extern "C" fn(
        pathOrNull: *const sk_path_t,
        matrix: *const sk_matrix_t,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_image_caching_hint_t {
    ALLOW_SK_IMAGE_CACHING_HINT = 0,
    DISALLOW_SK_IMAGE_CACHING_HINT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_bitmap_allocflags_t {
    NONE_SK_BITMAP_ALLOC_FLAGS = 0,
    ZERO_PIXELS_SK_BITMAP_ALLOC_FLAGS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_time_datetime_t {
    pub fTimeZoneMinutes: i16,
    pub fYear: u16,
    pub fMonth: u8,
    pub fDayOfWeek: u8,
    pub fDay: u8,
    pub fHour: u8,
    pub fMinute: u8,
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_sk_time_datetime_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_time_datetime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_time_datetime_t>(),
        10usize,
        concat!("Size of: ", stringify!(sk_time_datetime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_time_datetime_t>(),
        2usize,
        concat!("Alignment of ", stringify!(sk_time_datetime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTimeZoneMinutes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fTimeZoneMinutes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fYear) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fYear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMonth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fMonth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDayOfWeek) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDay) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fDay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHour) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fHour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMinute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fMinute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSecond) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_time_datetime_t),
            "::",
            stringify!(fSecond)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_document_pdf_metadata_t {
    pub fTitle: *mut sk_string_t,
    pub fAuthor: *mut sk_string_t,
    pub fSubject: *mut sk_string_t,
    pub fKeywords: *mut sk_string_t,
    pub fCreator: *mut sk_string_t,
    pub fProducer: *mut sk_string_t,
    pub fCreation: *mut sk_time_datetime_t,
    pub fModified: *mut sk_time_datetime_t,
    pub fRasterDPI: f32,
    pub fPDFA: bool,
    pub fEncodingQuality: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sk_document_pdf_metadata_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_document_pdf_metadata_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_document_pdf_metadata_t>(),
        80usize,
        concat!("Size of: ", stringify!(sk_document_pdf_metadata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_document_pdf_metadata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_document_pdf_metadata_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTitle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAuthor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fAuthor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSubject) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fSubject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fKeywords) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fKeywords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCreator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fCreator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fProducer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fProducer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCreation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fCreation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fModified) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fModified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRasterDPI) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fRasterDPI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPDFA) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fPDFA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fEncodingQuality) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_document_pdf_metadata_t),
            "::",
            stringify!(fEncodingQuality)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_imageinfo_t {
    pub colorspace: *mut sk_colorspace_t,
    pub width: i32,
    pub height: i32,
    pub colorType: sk_colortype_t,
    pub alphaType: sk_alphatype_t,
}
#[test]
fn bindgen_test_layout_sk_imageinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_imageinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_imageinfo_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_imageinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_imageinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_imageinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(colorType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alphaType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_imageinfo_t),
            "::",
            stringify!(alphaType)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_codecanimation_disposalmethod_t {
    KEEP_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 1,
    RESTORE_BG_COLOR_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 2,
    RESTORE_PREVIOUS_SK_CODEC_ANIMATION_DISPOSAL_METHOD = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_codecanimation_blend_t {
    SRC_OVER_SK_CODEC_ANIMATION_BLEND = 0,
    SRC_SK_CODEC_ANIMATION_BLEND = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_codec_frameinfo_t {
    pub fRequiredFrame: ::std::os::raw::c_int,
    pub fDuration: ::std::os::raw::c_int,
    pub fFullyReceived: bool,
    pub fAlphaType: sk_alphatype_t,
    pub fHasAlphaWithinBounds: bool,
    pub fDisposalMethod: sk_codecanimation_disposalmethod_t,
    pub fBlend: sk_codecanimation_blend_t,
    pub fFrameRect: sk_irect_t,
}
#[test]
fn bindgen_test_layout_sk_codec_frameinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_codec_frameinfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_codec_frameinfo_t>(),
        44usize,
        concat!("Size of: ", stringify!(sk_codec_frameinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_codec_frameinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_codec_frameinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRequiredFrame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fRequiredFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDuration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFullyReceived) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fFullyReceived)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlphaType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fAlphaType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHasAlphaWithinBounds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fHasAlphaWithinBounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDisposalMethod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fDisposalMethod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBlend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fBlend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFrameRect) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_codec_frameinfo_t),
            "::",
            stringify!(fFrameRect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_svgcanvas_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_vertices_vertex_mode_t {
    TRIANGLES_SK_VERTICES_VERTEX_MODE = 0,
    TRIANGLE_STRIP_SK_VERTICES_VERTEX_MODE = 1,
    TRIANGLE_FAN_SK_VERTICES_VERTEX_MODE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_vertices_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_transfer_fn_t {
    pub fG: f32,
    pub fA: f32,
    pub fB: f32,
    pub fC: f32,
    pub fD: f32,
    pub fE: f32,
    pub fF: f32,
}
#[test]
fn bindgen_test_layout_sk_colorspace_transfer_fn_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_colorspace_transfer_fn_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_colorspace_transfer_fn_t>(),
        28usize,
        concat!("Size of: ", stringify!(sk_colorspace_transfer_fn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_colorspace_transfer_fn_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_colorspace_transfer_fn_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fG) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fB) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fC) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fD) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fE) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fF) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_transfer_fn_t),
            "::",
            stringify!(fF)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_primaries_t {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_sk_colorspace_primaries_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_colorspace_primaries_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_colorspace_primaries_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_colorspace_primaries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_colorspace_primaries_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_colorspace_primaries_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fRX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fRY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fGX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fGY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fBX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fBY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWX) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fWX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_primaries_t),
            "::",
            stringify!(fWY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_xyz_t {
    pub fM00: f32,
    pub fM01: f32,
    pub fM02: f32,
    pub fM10: f32,
    pub fM11: f32,
    pub fM12: f32,
    pub fM20: f32,
    pub fM21: f32,
    pub fM22: f32,
}
#[test]
fn bindgen_test_layout_sk_colorspace_xyz_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_colorspace_xyz_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_colorspace_xyz_t>(),
        36usize,
        concat!("Size of: ", stringify!(sk_colorspace_xyz_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_colorspace_xyz_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_colorspace_xyz_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM00) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM00)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM01) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM01)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM02) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM02)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM10) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM11) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM12) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM20) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM20)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM21) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM21)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fM22) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_colorspace_xyz_t),
            "::",
            stringify!(fM22)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_colorspace_icc_profile_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_highcontrastconfig_invertstyle_t {
    NO_INVERT_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 0,
    INVERT_BRIGHTNESS_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 1,
    INVERT_LIGHTNESS_SK_HIGH_CONTRAST_CONFIG_INVERT_STYLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_highcontrastconfig_t {
    pub fGrayscale: bool,
    pub fInvertStyle: sk_highcontrastconfig_invertstyle_t,
    pub fContrast: f32,
}
#[test]
fn bindgen_test_layout_sk_highcontrastconfig_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_highcontrastconfig_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_highcontrastconfig_t>(),
        12usize,
        concat!("Size of: ", stringify!(sk_highcontrastconfig_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_highcontrastconfig_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_highcontrastconfig_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fGrayscale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fGrayscale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fInvertStyle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fInvertStyle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fContrast) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_highcontrastconfig_t),
            "::",
            stringify!(fContrast)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_pngencoder_filterflags_t {
    ZERO_SK_PNGENCODER_FILTER_FLAGS = 0,
    NONE_SK_PNGENCODER_FILTER_FLAGS = 8,
    SUB_SK_PNGENCODER_FILTER_FLAGS = 16,
    UP_SK_PNGENCODER_FILTER_FLAGS = 32,
    AVG_SK_PNGENCODER_FILTER_FLAGS = 64,
    PAETH_SK_PNGENCODER_FILTER_FLAGS = 128,
    ALL_SK_PNGENCODER_FILTER_FLAGS = 248,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_pngencoder_options_t {
    pub fFilterFlags: sk_pngencoder_filterflags_t,
    pub fZLibLevel: ::std::os::raw::c_int,
    pub fComments: *mut ::std::os::raw::c_void,
    pub fICCProfile: *const sk_colorspace_icc_profile_t,
    pub fICCProfileDescription: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sk_pngencoder_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_pngencoder_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_pngencoder_options_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_pngencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_pngencoder_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_pngencoder_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFilterFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fFilterFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fZLibLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fZLibLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fComments) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fComments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fICCProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfileDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_pngencoder_options_t),
            "::",
            stringify!(fICCProfileDescription)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_jpegencoder_downsample_t {
    DOWNSAMPLE_420_SK_JPEGENCODER_DOWNSAMPLE = 0,
    DOWNSAMPLE_422_SK_JPEGENCODER_DOWNSAMPLE = 1,
    DOWNSAMPLE_444_SK_JPEGENCODER_DOWNSAMPLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_jpegencoder_alphaoption_t {
    IGNORE_SK_JPEGENCODER_ALPHA_OPTION = 0,
    BLEND_ON_BLACK_SK_JPEGENCODER_ALPHA_OPTION = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_jpegencoder_options_t {
    pub fQuality: ::std::os::raw::c_int,
    pub fDownsample: sk_jpegencoder_downsample_t,
    pub fAlphaOption: sk_jpegencoder_alphaoption_t,
    pub xmpMetadata: *const sk_data_t,
    pub fICCProfile: *const sk_colorspace_icc_profile_t,
    pub fICCProfileDescription: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sk_jpegencoder_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_jpegencoder_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_jpegencoder_options_t>(),
        40usize,
        concat!("Size of: ", stringify!(sk_jpegencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_jpegencoder_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_jpegencoder_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fQuality) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fQuality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fDownsample) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fDownsample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlphaOption) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fAlphaOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmpMetadata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(xmpMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfile) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fICCProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfileDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_jpegencoder_options_t),
            "::",
            stringify!(fICCProfileDescription)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_webpencoder_compression_t {
    LOSSY_SK_WEBPENCODER_COMPTRESSION = 0,
    LOSSLESS_SK_WEBPENCODER_COMPTRESSION = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_webpencoder_options_t {
    pub fCompression: sk_webpencoder_compression_t,
    pub fQuality: f32,
    pub fICCProfile: *const sk_colorspace_icc_profile_t,
    pub fICCProfileDescription: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sk_webpencoder_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_webpencoder_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_webpencoder_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_webpencoder_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_webpencoder_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_webpencoder_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCompression) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fCompression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fQuality) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fQuality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fICCProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fICCProfileDescription) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_webpencoder_options_t),
            "::",
            stringify!(fICCProfileDescription)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_rrect_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_rrect_type_t {
    EMPTY_SK_RRECT_TYPE = 0,
    RECT_SK_RRECT_TYPE = 1,
    OVAL_SK_RRECT_TYPE = 2,
    SIMPLE_SK_RRECT_TYPE = 3,
    NINE_PATCH_SK_RRECT_TYPE = 4,
    COMPLEX_SK_RRECT_TYPE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_rrect_corner_t {
    UPPER_LEFT_SK_RRECT_CORNER = 0,
    UPPER_RIGHT_SK_RRECT_CORNER = 1,
    LOWER_RIGHT_SK_RRECT_CORNER = 2,
    LOWER_LEFT_SK_RRECT_CORNER = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_builder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_textblob_builder_runbuffer_t {
    pub glyphs: *mut ::std::os::raw::c_void,
    pub pos: *mut ::std::os::raw::c_void,
    pub utf8text: *mut ::std::os::raw::c_void,
    pub clusters: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sk_textblob_builder_runbuffer_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_textblob_builder_runbuffer_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_textblob_builder_runbuffer_t>(),
        32usize,
        concat!("Size of: ", stringify!(sk_textblob_builder_runbuffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_textblob_builder_runbuffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_textblob_builder_runbuffer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(utf8text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clusters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_textblob_builder_runbuffer_t),
            "::",
            stringify!(clusters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_rsxform_t {
    pub fSCos: f32,
    pub fSSin: f32,
    pub fTX: f32,
    pub fTY: f32,
}
#[test]
fn bindgen_test_layout_sk_rsxform_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_rsxform_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_rsxform_t>(),
        16usize,
        concat!("Size of: ", stringify!(sk_rsxform_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_rsxform_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_rsxform_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSCos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rsxform_t),
            "::",
            stringify!(fSCos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSSin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rsxform_t),
            "::",
            stringify!(fSSin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rsxform_t),
            "::",
            stringify!(fTX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_rsxform_t),
            "::",
            stringify!(fTY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_tracememorydump_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_runtimeeffect_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_runtimeeffect_uniform_type_t {
    FLOAT_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 0,
    FLOAT2_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 1,
    FLOAT3_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 2,
    FLOAT4_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 3,
    FLOAT2X2_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 4,
    FLOAT3X3_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 5,
    FLOAT4X4_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 6,
    INT_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 7,
    INT2_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 8,
    INT3_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 9,
    INT4_SK_RUNTIMEEFFECT_UNIFORM_TYPE = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_runtimeeffect_child_type_t {
    SHADER_SK_RUNTIMEEFFECT_CHILD_TYPE = 0,
    COLOR_FILTER_SK_RUNTIMEEFFECT_CHILD_TYPE = 1,
    BLENDER_SK_RUNTIMEEFFECT_CHILD_TYPE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_runtimeeffect_uniform_flags_t {
    NONE_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 0,
    ARRAY_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 1,
    COLOR_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 2,
    VERTEX_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 4,
    FRAGMENT_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 8,
    HALF_PRECISION_SK_RUNTIMEEFFECT_UNIFORM_FLAGS = 16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_runtimeeffect_uniform_t {
    pub fName: *const ::std::os::raw::c_char,
    pub fNameLength: usize,
    pub fOffset: usize,
    pub fType: sk_runtimeeffect_uniform_type_t,
    pub fCount: ::std::os::raw::c_int,
    pub fFlags: sk_runtimeeffect_uniform_flags_t,
}
#[test]
fn bindgen_test_layout_sk_runtimeeffect_uniform_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_runtimeeffect_uniform_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_runtimeeffect_uniform_t>(),
        40usize,
        concat!("Size of: ", stringify!(sk_runtimeeffect_uniform_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_runtimeeffect_uniform_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_runtimeeffect_uniform_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_uniform_t),
            "::",
            stringify!(fFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_runtimeeffect_child_t {
    pub fName: *const ::std::os::raw::c_char,
    pub fNameLength: usize,
    pub fType: sk_runtimeeffect_child_type_t,
    pub fIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sk_runtimeeffect_child_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_runtimeeffect_child_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_runtimeeffect_child_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_runtimeeffect_child_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_runtimeeffect_child_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sk_runtimeeffect_child_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_child_t),
            "::",
            stringify!(fName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_child_t),
            "::",
            stringify!(fNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_child_t),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fIndex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_runtimeeffect_child_t),
            "::",
            stringify!(fIndex)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_filter_mode_t {
    NEAREST_SK_FILTER_MODE = 0,
    LINEAR_SK_FILTER_MODE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sk_mipmap_mode_t {
    NONE_SK_MIPMAP_MODE = 0,
    NEAREST_SK_MIPMAP_MODE = 1,
    LINEAR_SK_MIPMAP_MODE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_cubic_resampler_t {
    pub fB: f32,
    pub fC: f32,
}
#[test]
fn bindgen_test_layout_sk_cubic_resampler_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_cubic_resampler_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_cubic_resampler_t>(),
        8usize,
        concat!("Size of: ", stringify!(sk_cubic_resampler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_cubic_resampler_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_cubic_resampler_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fB) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_cubic_resampler_t),
            "::",
            stringify!(fB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fC) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_cubic_resampler_t),
            "::",
            stringify!(fC)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_sampling_options_t {
    pub fMaxAniso: ::std::os::raw::c_int,
    pub fUseCubic: bool,
    pub fCubic: sk_cubic_resampler_t,
    pub fFilter: sk_filter_mode_t,
    pub fMipmap: sk_mipmap_mode_t,
}
#[test]
fn bindgen_test_layout_sk_sampling_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<sk_sampling_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sk_sampling_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(sk_sampling_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sk_sampling_options_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sk_sampling_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMaxAniso) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_sampling_options_t),
            "::",
            stringify!(fMaxAniso)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fUseCubic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_sampling_options_t),
            "::",
            stringify!(fUseCubic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fCubic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_sampling_options_t),
            "::",
            stringify!(fCubic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fFilter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_sampling_options_t),
            "::",
            stringify!(fFilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMipmap) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sk_sampling_options_t),
            "::",
            stringify!(fMipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_animation_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_animation_builder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_resource_provider_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_property_observer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_logger_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skottie_marker_observer_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sksg_invalidation_controller_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skottie_animation_renderflags_t {
    SKIP_TOP_LEVEL_ISOLATION = 1,
    DISABLE_TOP_LEVEL_CLIPPING = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_font_arguments_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_affinity_t {
    UPSTREAM_AFFINITY = 0,
    DOWNSTREAM_AFFINITY = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_rect_height_style_t {
    TIGHT_RECT_HEIGHT_STYLE = 0,
    MAX_RECT_HEIGHT_STYLE = 1,
    INCLUDE_LINE_SPACING_MIDDLE_RECT_HEIGHT_STYLE = 2,
    INCLUDE_LINE_SPACING_TOP_RECT_HEIGHT_STYLE = 3,
    INCLUDE_LINE_SPACING_BOTTOM_RECT_HEIGHT_STYLE = 4,
    STRUT_RECT_HEIGHT_STYLE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_rect_width_style_t {
    TIGHT_RECT_WIDTH_STYLE = 0,
    MAX_RECT_WIDTH_STYLE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_align_t {
    LEFT_TEXT_ALIGN = 0,
    RIGHT_TEXT_ALIGN = 1,
    CENTER_TEXT_ALIGN = 2,
    JUSTIFY_TEXT_ALIGN = 3,
    START_TEXT_ALIGN = 4,
    END_TEXT_ALIGN = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_direction_t {
    RTL_TEXT_DIRECTION = 0,
    LTR_TEXT_DIRECTION = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_position_with_affinity_t {
    pub position: i32,
    pub affinity: tl_affinity_t,
}
#[test]
fn bindgen_test_layout_tl_position_with_affinity_t() {
    const UNINIT: ::std::mem::MaybeUninit<tl_position_with_affinity_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_position_with_affinity_t>(),
        8usize,
        concat!("Size of: ", stringify!(tl_position_with_affinity_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_position_with_affinity_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_position_with_affinity_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_position_with_affinity_t),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).affinity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_position_with_affinity_t),
            "::",
            stringify!(affinity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_text_box_t {
    pub rect: sk_rect_t,
    pub direction: tl_text_direction_t,
}
#[test]
fn bindgen_test_layout_tl_text_box_t() {
    const UNINIT: ::std::mem::MaybeUninit<tl_text_box_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_text_box_t>(),
        20usize,
        concat!("Size of: ", stringify!(tl_text_box_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_text_box_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_text_box_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_text_box_t),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_text_box_t),
            "::",
            stringify!(direction)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_baseline_t {
    ALPHABETIC_TEXT_BASELINE = 0,
    IDEOGRAPHIC_TEXT_BASELINE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_height_behavior_t {
    ALL_TEXT_HEIGHT_BEHAVIOR = 0,
    DISABLE_FIRST_ASCENT_TEXT_HEIGHT_BEHAVIOR = 1,
    DISABLE_LAST_DESCENT_TEXT_HEIGHT_BEHAVIOR = 2,
    DISABLE_ALL_TEXT_HEIGHT_BEHAVIOR = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_line_metric_style_t {
    TYPOGRAPHIC_LINE_METRIC_STYLE = 0,
    CSS_LINE_METRIC_STYLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_text_shadow_t {
    pub fColor: sk_color_t,
    pub fOffset: sk_point_t,
    pub fBlurSigma: f64,
}
#[test]
fn bindgen_test_layout_tl_text_shadow_t() {
    const UNINIT: ::std::mem::MaybeUninit<tl_text_shadow_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_text_shadow_t>(),
        24usize,
        concat!("Size of: ", stringify!(tl_text_shadow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_text_shadow_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tl_text_shadow_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_text_shadow_t),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_text_shadow_t),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBlurSigma) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_text_shadow_t),
            "::",
            stringify!(fBlurSigma)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_decoration_t {
    NO_DECORATION = 0,
    UNDERLINE = 1,
    OVERLINE = 2,
    LINE_THROUGH = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_decoration_style_t {
    SOLID_TEXT_DECORATION_STYLE = 0,
    DOUBLE_TEXT_DECORATION_STYLE = 1,
    DOTTED_TEXT_DECORATION_STYLE = 2,
    DASHED_TEXT_DECORATION_STYLE = 3,
    WAVY_TEXT_DECORATION_STYLE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_text_decoration_mode_t {
    GAPS_TEXT_DECORATION_MODE = 0,
    THROUGH_TEXT_DECORATION_MODE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_style_type_t {
    NONE_STYLE_TYPE = 0,
    ALL_ATTRIBUTES_STYLE_TYPE = 1,
    FONT_STYLE_TYPE = 2,
    FOREGROUND_STYLE_TYPE = 3,
    BACKGROUND_STYLE_TYPE = 4,
    SHADOW_STYLE_TYPE = 5,
    DECORATIONS_STYLE_TYPE = 6,
    LETTER_SPACING_STYLE_TYPE = 7,
    WORD_SPACING_STYLE_TYPE = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tl_placeholder_alignment_t {
    BASELINE_PLACEHOLDER_ALIGNMENT = 0,
    ABOVE_BASELINE_PLACEHOLDER_ALIGNMENT = 1,
    BELOW_BASELINE_PLACEHOLDER_ALIGNMENT = 2,
    TOP_PLACEHOLDER_ALIGNMENT = 3,
    BOTTOM_PLACEHOLDER_ALIGNMENT = 4,
    MIDDLE_PLACEHOLDER_ALIGNMENT = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_placeholder_style_t {
    pub fWidth: f32,
    pub fHeight: f32,
    pub fAlignment: tl_placeholder_alignment_t,
    pub fBaseline: tl_text_baseline_t,
    pub fBaselineOffset: f32,
}
#[test]
fn bindgen_test_layout_tl_placeholder_style_t() {
    const UNINIT: ::std::mem::MaybeUninit<tl_placeholder_style_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_placeholder_style_t>(),
        20usize,
        concat!("Size of: ", stringify!(tl_placeholder_style_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_placeholder_style_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_placeholder_style_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_placeholder_style_t),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_placeholder_style_t),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_placeholder_style_t),
            "::",
            stringify!(fAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBaseline) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_placeholder_style_t),
            "::",
            stringify!(fBaseline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fBaselineOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_placeholder_style_t),
            "::",
            stringify!(fBaselineOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_decoration_t {
    pub fType: tl_text_decoration_t,
    pub fMode: tl_text_decoration_mode_t,
    pub fColor: sk_color_t,
    pub fStyle: tl_text_decoration_style_t,
    pub fThicknessMultiplier: f32,
}
#[test]
fn bindgen_test_layout_tl_decoration_t() {
    const UNINIT: ::std::mem::MaybeUninit<tl_decoration_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_decoration_t>(),
        20usize,
        concat!("Size of: ", stringify!(tl_decoration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_decoration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_decoration_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_decoration_t),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_decoration_t),
            "::",
            stringify!(fMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_decoration_t),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_decoration_t),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fThicknessMultiplier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_decoration_t),
            "::",
            stringify!(fThicknessMultiplier)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_text_style_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_dash_path_effect {
    pub fOnLength: f32,
    pub fOffLength: f32,
}
#[test]
fn bindgen_test_layout_tl_dash_path_effect() {
    const UNINIT: ::std::mem::MaybeUninit<tl_dash_path_effect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_dash_path_effect>(),
        8usize,
        concat!("Size of: ", stringify!(tl_dash_path_effect))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_dash_path_effect>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_dash_path_effect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOnLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_dash_path_effect),
            "::",
            stringify!(fOnLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fOffLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_dash_path_effect),
            "::",
            stringify!(fOffLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_strut_style_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_paragraph_style_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_font_collection_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_vec_of_sk_strings_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_paragraph_builder_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_paragraph_t {
    _unused: [u8; 0],
}
pub type vec_resize_and_return_ptr =
    ::std::option::Option<unsafe extern "C" fn(len: usize) -> *mut ::std::os::raw::c_void>;
extern "C" {
    pub fn gr_recording_context_unref(context: *mut gr_recording_context_t);
    pub fn gr_recording_context_get_max_surface_sample_count_for_color_type(
        context: *mut gr_recording_context_t,
        colorType: sk_colortype_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_recording_context_get_backend(context: *mut gr_recording_context_t) -> gr_backend_t;
    pub fn gr_recording_context_is_abandoned(context: *mut gr_recording_context_t) -> bool;
    pub fn gr_recording_context_max_texture_size(
        context: *mut gr_recording_context_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_recording_context_max_render_target_size(
        context: *mut gr_recording_context_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_direct_context_make_gl(
        glInterface: *const gr_glinterface_t,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_make_gl_with_options(
        glInterface: *const gr_glinterface_t,
        options: *const gr_context_options_t,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_make_vulkan(
        vkBackendContext: gr_vk_backendcontext_t,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_make_vulkan_with_options(
        vkBackendContext: gr_vk_backendcontext_t,
        options: *const gr_context_options_t,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_make_metal(
        device: *mut ::std::os::raw::c_void,
        queue: *mut ::std::os::raw::c_void,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_make_metal_with_options(
        device: *mut ::std::os::raw::c_void,
        queue: *mut ::std::os::raw::c_void,
        options: *const gr_context_options_t,
    ) -> *mut gr_direct_context_t;
    pub fn gr_direct_context_is_abandoned(context: *mut gr_direct_context_t) -> bool;
    pub fn gr_direct_context_abandon_context(context: *mut gr_direct_context_t);
    pub fn gr_direct_context_release_resources_and_abandon_context(
        context: *mut gr_direct_context_t,
    );
    pub fn gr_direct_context_get_resource_cache_limit(context: *mut gr_direct_context_t) -> usize;
    pub fn gr_direct_context_set_resource_cache_limit(
        context: *mut gr_direct_context_t,
        maxResourceBytes: usize,
    );
    pub fn gr_direct_context_get_resource_cache_usage(
        context: *mut gr_direct_context_t,
        maxResources: *mut ::std::os::raw::c_int,
        maxResourceBytes: *mut usize,
    );
    pub fn gr_direct_context_flush(context: *mut gr_direct_context_t);
    pub fn gr_direct_context_submit(context: *mut gr_direct_context_t, syncCpu: bool) -> bool;
    pub fn gr_direct_context_flush_and_submit(context: *mut gr_direct_context_t, syncCpu: bool);
    pub fn gr_direct_context_reset_context(context: *mut gr_direct_context_t, state: u32);
    pub fn gr_direct_context_dump_memory_statistics(
        context: *const gr_direct_context_t,
        dump: *mut sk_tracememorydump_t,
    );
    pub fn gr_direct_context_free_gpu_resources(context: *mut gr_direct_context_t);
    pub fn gr_direct_context_perform_deferred_cleanup(
        context: *mut gr_direct_context_t,
        ms: ::std::os::raw::c_longlong,
    );
    pub fn gr_direct_context_purge_unlocked_resources_bytes(
        context: *mut gr_direct_context_t,
        bytesToPurge: usize,
        preferScratchResources: bool,
    );
    pub fn gr_direct_context_purge_unlocked_resources(
        context: *mut gr_direct_context_t,
        scratchResourcesOnly: bool,
    );
    pub fn gr_glinterface_create_native_interface() -> *const gr_glinterface_t;
    pub fn gr_glinterface_assemble_interface(
        ctx: *mut ::std::os::raw::c_void,
        get: gr_gl_get_proc,
    ) -> *const gr_glinterface_t;
    pub fn gr_glinterface_assemble_gl_interface(
        ctx: *mut ::std::os::raw::c_void,
        get: gr_gl_get_proc,
    ) -> *const gr_glinterface_t;
    pub fn gr_glinterface_assemble_gles_interface(
        ctx: *mut ::std::os::raw::c_void,
        get: gr_gl_get_proc,
    ) -> *const gr_glinterface_t;
    pub fn gr_glinterface_assemble_webgl_interface(
        ctx: *mut ::std::os::raw::c_void,
        get: gr_gl_get_proc,
    ) -> *const gr_glinterface_t;
    pub fn gr_glinterface_unref(glInterface: *const gr_glinterface_t);
    pub fn gr_glinterface_validate(glInterface: *const gr_glinterface_t) -> bool;
    pub fn gr_glinterface_has_extension(
        glInterface: *const gr_glinterface_t,
        extension: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn gr_vk_extensions_new() -> *mut gr_vk_extensions_t;
    pub fn gr_vk_extensions_delete(extensions: *mut gr_vk_extensions_t);
    pub fn gr_vk_extensions_init(
        extensions: *mut gr_vk_extensions_t,
        getProc: gr_vk_get_proc,
        userData: *mut ::std::os::raw::c_void,
        instance: *mut vk_instance_t,
        physDev: *mut vk_physical_device_t,
        instanceExtensionCount: u32,
        instanceExtensions: *mut *const ::std::os::raw::c_char,
        deviceExtensionCount: u32,
        deviceExtensions: *mut *const ::std::os::raw::c_char,
    );
    pub fn gr_vk_extensions_has_extension(
        extensions: *mut gr_vk_extensions_t,
        ext: *const ::std::os::raw::c_char,
        minVersion: u32,
    ) -> bool;
    pub fn gr_backendtexture_new_gl(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        mipmapped: bool,
        glInfo: *const gr_gl_textureinfo_t,
    ) -> *mut gr_backendtexture_t;
    pub fn gr_backendtexture_new_vulkan(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        vkInfo: *const gr_vk_imageinfo_t,
    ) -> *mut gr_backendtexture_t;
    pub fn gr_backendtexture_new_metal(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        mipmapped: bool,
        mtlInfo: *const gr_mtl_textureinfo_t,
    ) -> *mut gr_backendtexture_t;
    pub fn gr_backendtexture_delete(texture: *mut gr_backendtexture_t);
    pub fn gr_backendtexture_is_valid(texture: *const gr_backendtexture_t) -> bool;
    pub fn gr_backendtexture_get_width(
        texture: *const gr_backendtexture_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendtexture_get_height(
        texture: *const gr_backendtexture_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendtexture_has_mipmaps(texture: *const gr_backendtexture_t) -> bool;
    pub fn gr_backendtexture_get_backend(texture: *const gr_backendtexture_t) -> gr_backend_t;
    pub fn gr_backendtexture_get_gl_textureinfo(
        texture: *const gr_backendtexture_t,
        glInfo: *mut gr_gl_textureinfo_t,
    ) -> bool;
    pub fn gr_backendrendertarget_new_gl(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        samples: ::std::os::raw::c_int,
        stencils: ::std::os::raw::c_int,
        glInfo: *const gr_gl_framebufferinfo_t,
    ) -> *mut gr_backendrendertarget_t;
    pub fn gr_backendrendertarget_new_vulkan(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        samples: ::std::os::raw::c_int,
        vkImageInfo: *const gr_vk_imageinfo_t,
    ) -> *mut gr_backendrendertarget_t;
    pub fn gr_backendrendertarget_new_metal(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        samples: ::std::os::raw::c_int,
        mtlInfo: *const gr_mtl_textureinfo_t,
    ) -> *mut gr_backendrendertarget_t;
    pub fn gr_backendrendertarget_delete(rendertarget: *mut gr_backendrendertarget_t);
    pub fn gr_backendrendertarget_is_valid(rendertarget: *const gr_backendrendertarget_t) -> bool;
    pub fn gr_backendrendertarget_get_width(
        rendertarget: *const gr_backendrendertarget_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendrendertarget_get_height(
        rendertarget: *const gr_backendrendertarget_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendrendertarget_get_samples(
        rendertarget: *const gr_backendrendertarget_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendrendertarget_get_stencils(
        rendertarget: *const gr_backendrendertarget_t,
    ) -> ::std::os::raw::c_int;
    pub fn gr_backendrendertarget_get_backend(
        rendertarget: *const gr_backendrendertarget_t,
    ) -> gr_backend_t;
    pub fn gr_backendrendertarget_get_gl_framebufferinfo(
        rendertarget: *const gr_backendrendertarget_t,
        glInfo: *mut gr_gl_framebufferinfo_t,
    ) -> bool;
    pub fn tl_font_arguments_from_sk_fontarguments(
        args: *const sk_fontarguments_t,
    ) -> *mut tl_font_arguments_t;
    pub fn tl_font_arguments_delete(args: *mut tl_font_arguments_t);
    pub fn tl_text_style_new() -> *mut tl_text_style_t;
    pub fn tl_text_style_delete(ts: *mut tl_text_style_t);
    pub fn tl_text_style_get_color(ts: *const tl_text_style_t) -> sk_color_t;
    pub fn tl_text_style_set_color(ts: *mut tl_text_style_t, color: sk_color_t);
    pub fn tl_text_style_has_foreground(ts: *const tl_text_style_t) -> bool;
    pub fn tl_text_style_get_foreground(ts: *const tl_text_style_t) -> *mut sk_paint_t;
    pub fn tl_text_style_set_foreground_paint(ts: *mut tl_text_style_t, cpaint: *const sk_paint_t);
    pub fn tl_text_style_clear_foreground_color(ts: *mut tl_text_style_t);
    pub fn tl_text_style_has_background(ts: *const tl_text_style_t) -> bool;
    pub fn tl_text_style_get_background(ts: *const tl_text_style_t) -> *mut sk_paint_t;
    pub fn tl_text_style_set_background_paint(ts: *mut tl_text_style_t, cpaint: *const sk_paint_t);
    pub fn tl_text_style_clear_background_color(ts: *mut tl_text_style_t);
    pub fn tl_text_style_get_decoration(ts: *const tl_text_style_t, result: *mut tl_decoration_t);
    pub fn tl_text_style_get_decoration_type(ts: *const tl_text_style_t) -> tl_text_decoration_t;
    pub fn tl_text_style_get_decoration_mode(
        ts: *const tl_text_style_t,
    ) -> tl_text_decoration_mode_t;
    pub fn tl_text_style_get_decoration_color(ts: *const tl_text_style_t) -> sk_color_t;
    pub fn tl_text_style_get_decoration_style(
        ts: *const tl_text_style_t,
    ) -> tl_text_decoration_style_t;
    pub fn tl_text_style_get_decoration_thickness_multiplier(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_font_style(ts: *const tl_text_style_t) -> *mut sk_fontstyle_t;
    pub fn tl_text_style_get_shadow_number(ts: *const tl_text_style_t) -> usize;
    pub fn tl_text_style_get_font_feature_number(ts: *const tl_text_style_t) -> usize;
    pub fn tl_text_style_get_font_size(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_baseline_shift(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_height(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_height_override(ts: *const tl_text_style_t) -> bool;
    pub fn tl_text_style_get_half_leading(ts: *const tl_text_style_t) -> bool;
    pub fn tl_text_style_get_letter_spacing(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_word_spacing(ts: *const tl_text_style_t) -> f32;
    pub fn tl_text_style_get_typeface(ts: *const tl_text_style_t) -> *mut sk_typeface_t;
    pub fn tl_text_style_get_locale(ts: *const tl_text_style_t) -> *mut sk_string_t;
    pub fn tl_text_style_get_text_baseline(ts: *const tl_text_style_t) -> tl_text_baseline_t;
    pub fn tl_text_style_set_decoration_type(ts: *mut tl_text_style_t, value: tl_text_decoration_t);
    pub fn tl_text_style_set_decoration_mode(
        ts: *mut tl_text_style_t,
        value: tl_text_decoration_mode_t,
    );
    pub fn tl_text_style_set_decoration_color(ts: *mut tl_text_style_t, value: sk_color_t);
    pub fn tl_text_style_set_decoration_style(
        ts: *mut tl_text_style_t,
        value: tl_text_decoration_style_t,
    );
    pub fn tl_text_style_set_decoration_thickness_multiplier(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_font_style(ts: *mut tl_text_style_t, value: *const sk_fontstyle_t);
    pub fn tl_text_style_set_shadow_number(ts: *mut tl_text_style_t, value: usize);
    pub fn tl_text_style_set_font_feature_number(ts: *mut tl_text_style_t, value: usize);
    pub fn tl_text_style_set_font_size(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_baseline_shift(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_height(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_height_override(ts: *mut tl_text_style_t, value: bool);
    pub fn tl_text_style_set_half_leading(ts: *mut tl_text_style_t, value: bool);
    pub fn tl_text_style_set_letter_spacing(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_word_spacing(ts: *mut tl_text_style_t, value: f32);
    pub fn tl_text_style_set_typeface(ts: *mut tl_text_style_t, value: *const sk_typeface_t);
    pub fn tl_text_style_set_locale(ts: *mut tl_text_style_t, value: *const sk_string_t);
    pub fn tl_text_style_set_text_baseline(ts: *mut tl_text_style_t, value: tl_text_baseline_t);
    pub fn tl_text_style_reset_shadows(ts: *mut tl_text_style_t);
    pub fn tl_text_style_reset_font_features(ts: *mut tl_text_style_t);
    pub fn tl_strut_style_new() -> *mut tl_strut_style_t;
    pub fn tl_strut_style_delete(strut_style: *mut tl_strut_style_t);
    pub fn tl_strut_get_font_style(cstrut_style: *const tl_strut_style_t) -> *mut sk_fontstyle_t;
    pub fn tl_strut_set_font_style(
        strut_style: *mut tl_strut_style_t,
        font_style: *const sk_fontstyle_t,
    );
    pub fn tl_strut_get_font_size(cstrut_style: *const tl_strut_style_t) -> f32;
    pub fn tl_strut_set_font_size(strut_style: *mut tl_strut_style_t, font_size: f32);
    pub fn tl_strut_get_height(cstrut_style: *const tl_strut_style_t) -> f32;
    pub fn tl_strut_set_height(strut_style: *mut tl_strut_style_t, height: f32);
    pub fn tl_strut_get_leading(cstrut_style: *const tl_strut_style_t) -> f32;
    pub fn tl_strut_set_leading(strut_style: *mut tl_strut_style_t, leading: f32);
    pub fn tl_strut_get_strut_enabled(cstrut_style: *const tl_strut_style_t) -> bool;
    pub fn tl_strut_set_strut_enabled(strut_style: *mut tl_strut_style_t, enabled: bool);
    pub fn tl_strut_get_force_strut_height(cstrut_style: *const tl_strut_style_t) -> bool;
    pub fn tl_strut_set_force_strut_height(strut_style: *mut tl_strut_style_t, force: bool);
    pub fn tl_strut_get_height_override(cstrut_style: *const tl_strut_style_t) -> bool;
    pub fn tl_strut_set_height_override(strut_style: *mut tl_strut_style_t, override_height: bool);
    pub fn tl_paragraph_style_new() -> *mut tl_paragraph_style_t;
    pub fn tl_paragraph_style_delete(paragraph_style: *mut tl_paragraph_style_t);
    pub fn tl_paragraph_style_get_strut_style(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> *mut tl_strut_style_t;
    pub fn tl_paragraph_style_set_strut_style(
        cparagraph_style: *mut tl_paragraph_style_t,
        cstrut_style: *const tl_strut_style_t,
    );
    pub fn tl_paragraph_style_get_text_style(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> *mut tl_text_style_t;
    pub fn tl_paragraph_style_set_text_style(
        cparagraph_style: *mut tl_paragraph_style_t,
        ctext_style: *const tl_text_style_t,
    );
    pub fn tl_paragraph_style_get_text_direction(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> tl_text_direction_t;
    pub fn tl_paragraph_style_set_text_direction(
        cparagraph_style: *mut tl_paragraph_style_t,
        text_direction: tl_text_direction_t,
    );
    pub fn tl_paragraph_style_get_text_align(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> tl_text_align_t;
    pub fn tl_paragraph_style_set_text_align(
        cparagraph_style: *mut tl_paragraph_style_t,
        text_align: tl_text_align_t,
    );
    pub fn tl_paragraph_style_get_max_lines(cparagraph_style: *const tl_paragraph_style_t)
        -> usize;
    pub fn tl_paragraph_style_set_max_lines(
        cparagraph_style: *mut tl_paragraph_style_t,
        max_lines: usize,
    );
    pub fn tl_paragraph_style_get_ellipsis(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> *mut sk_string_t;
    pub fn tl_paragraph_style_set_ellipsis(
        cparagraph_style: *mut tl_paragraph_style_t,
        ellipsis: *const sk_string_t,
    );
    pub fn tl_paragraph_style_get_height(cparagraph_style: *const tl_paragraph_style_t) -> f32;
    pub fn tl_paragraph_style_set_height(cparagraph_style: *mut tl_paragraph_style_t, height: f32);
    pub fn tl_paragraph_style_get_text_height_behavior(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> tl_text_height_behavior_t;
    pub fn tl_paragraph_style_set_text_height_behavior(
        cparagraph_style: *mut tl_paragraph_style_t,
        text_height_behavior: tl_text_height_behavior_t,
    );
    pub fn tl_paragraph_style_get_replace_tab_characters(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> bool;
    pub fn tl_paragraph_style_set_replace_tab_characters(
        cparagraph_style: *mut tl_paragraph_style_t,
        value: bool,
    );
    pub fn tl_paragraph_style_get_apply_rounding_hack(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> bool;
    pub fn tl_paragraph_style_set_apply_rounding_hack(
        cparagraph_style: *mut tl_paragraph_style_t,
        value: bool,
    );
    pub fn tl_paragraph_style_hinting_is_on(cparagraph_style: *const tl_paragraph_style_t) -> bool;
    pub fn tl_paragraph_style_turn_hinting_off(cparagraph_style: *mut tl_paragraph_style_t);
    pub fn tl_paragraph_style_unlimited_lines(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> bool;
    pub fn tl_paragraph_style_ellipsized(cparagraph_style: *const tl_paragraph_style_t) -> bool;
    pub fn tl_paragraph_style_effective_align(
        cparagraph_style: *const tl_paragraph_style_t,
    ) -> tl_text_align_t;
    pub fn tl_font_collection_ref(font_collection: *mut tl_font_collection_t);
    pub fn tl_font_collection_unref(font_collection: *mut tl_font_collection_t);
    pub fn tl_font_collection_new() -> *mut tl_font_collection_t;
    pub fn tl_font_collection_set_asset_font_manager(
        font_collection: *mut tl_font_collection_t,
        cfontmgr: *const sk_fontmgr_t,
    );
    pub fn tl_font_collection_set_dynamic_font_manager(
        font_collection: *mut tl_font_collection_t,
        cfontmgr: *const sk_fontmgr_t,
    );
    pub fn tl_font_collection_set_test_font_manager(
        font_collection: *mut tl_font_collection_t,
        arg1: *const sk_fontmgr_t,
    );
    pub fn tl_font_collection_set_default_font_manager(
        arg1: *mut tl_font_collection_t,
        cfontmgr: *const sk_fontmgr_t,
    );
    pub fn tl_font_collection_set_default_font_manager_with_family_name(
        font_collection: *mut tl_font_collection_t,
        cfontmgr: *const sk_fontmgr_t,
        default_family_name: *const ::std::os::raw::c_char,
    );
    pub fn tl_font_collection_get_fallback_font_manager(
        arg1: *const tl_font_collection_t,
    ) -> *mut sk_fontmgr_t;
    pub fn tl_font_collection_find_typefaces(
        arg1: *mut tl_font_collection_t,
        arg2: *const tl_vec_of_sk_strings_t,
        arg3: *const sk_fontstyle_t,
        vec_typeface_or_null: *mut *mut sk_typeface_t,
        vec_len: usize,
    ) -> usize;
    pub fn tl_font_collection_find_typefaces2(
        arg1: *mut tl_font_collection_t,
        arg2: *const tl_vec_of_sk_strings_t,
        arg3: *const sk_fontstyle_t,
        font_args_or_null: *const tl_font_arguments_t,
        vec_typeface_or_null: *mut *mut sk_typeface_t,
        vec_len: usize,
    ) -> usize;
    pub fn tl_font_collection_disable_font_fallback(font_collection: *mut tl_font_collection_t);
    pub fn tl_font_collection_enable_font_fallback(font_collection: *mut tl_font_collection_t);
    pub fn tl_font_collection_font_fallback_enabled(
        font_collection: *mut tl_font_collection_t,
    ) -> bool;
    pub fn tl_paragraph_builder_new(
        paragraph_style: *const tl_paragraph_style_t,
        font_collection: *const tl_font_collection_t,
    ) -> *mut tl_paragraph_builder_t;
    pub fn tl_paragraph_builder_delete(builder: *mut tl_paragraph_builder_t);
    pub fn tl_paragraph_builder_push_style(
        paragraph_builder: *mut tl_paragraph_builder_t,
        text_style: *const tl_text_style_t,
    );
    pub fn tl_paragraph_builder_pop(paragraph_builder: *mut tl_paragraph_builder_t);
    pub fn tl_paragraph_builder_peek_style(
        paragraph_builder: *mut tl_paragraph_builder_t,
    ) -> *mut tl_text_style_t;
    pub fn tl_paragraph_builder_add_text(
        paragraph_builder: *mut tl_paragraph_builder_t,
        text: *const ::std::os::raw::c_char,
        len: usize,
    );
    pub fn tl_paragraph_builder_add_place_holder(
        paragraph_builder: *mut tl_paragraph_builder_t,
        place_holder_style: *const tl_placeholder_style_t,
    );
    pub fn tl_paragraph_builder_build(
        paragraph_builder: *mut tl_paragraph_builder_t,
    ) -> *mut tl_paragraph_t;
    pub fn tl_paragraph_builder_get_text(
        paragraph_builder: *mut tl_paragraph_builder_t,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn tl_paragraph_builder_reset(paragraph_builder: *mut tl_paragraph_builder_t);
    pub fn tl_paragraph_delete(paragraph: *mut tl_paragraph_t);
    pub fn tl_paragraph_get_max_width(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_height(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_min_intrinsic_width(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_max_intrinsic_width(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_alphabetic_baseline(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_ideographic_baseline(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_longest_line(paragraph: *mut tl_paragraph_t) -> f32;
    pub fn tl_paragraph_get_did_exceed_max_lines(paragraph: *mut tl_paragraph_t) -> bool;
    pub fn tl_paragraph_layout(paragraph: *mut tl_paragraph_t, width: f32);
    pub fn tl_paragraph_paint(
        paragraph: *mut tl_paragraph_t,
        canvas: *mut sk_canvas_t,
        x: f32,
        y: f32,
    );
    pub fn tl_paragraph_get_rects_for_range(
        paragraph: *mut tl_paragraph_t,
        start: u32,
        end: u32,
        hstyle: tl_rect_height_style_t,
        wstyle: tl_rect_width_style_t,
        vec_text_box_or_null: *mut tl_text_box_t,
        vec_len: usize,
    ) -> usize;
    pub fn tl_paragraph_get_rects_for_placeholders(
        paragraph: *mut tl_paragraph_t,
        vec_text_box_or_null: *mut tl_text_box_t,
        vec_len: usize,
    ) -> usize;
    pub fn tl_paragraph_get_glyph_position_at_coordinate(
        paragraph: *mut tl_paragraph_t,
        dx: f32,
        dy: f32,
        result: *mut tl_position_with_affinity_t,
    );
    pub fn tl_paragraph_get_word_boundary(
        paragraph: *mut tl_paragraph_t,
        offset: u32,
        start: *mut usize,
        end: *mut usize,
    );
    pub fn tl_paragraph_line_number(paragraph: *mut tl_paragraph_t) -> usize;
    pub fn tl_paragraph_mark_dirty(paragraph: *mut tl_paragraph_t);
    pub fn tl_paragraph_unresolved_glyphs(paragraph: *mut tl_paragraph_t) -> i32;
    pub fn tl_paragraph_update_text_align(
        paragraph: *mut tl_paragraph_t,
        text_align: tl_text_align_t,
    );
    pub fn tl_paragraph_update_font_size(
        paragraph: *mut tl_paragraph_t,
        from: usize,
        to: usize,
        font_size: f32,
    );
    pub fn tl_paragraph_update_foreground_paint(
        paragraph: *mut tl_paragraph_t,
        from: usize,
        to: usize,
        cpaint: *const sk_paint_t,
    );
    pub fn tl_paragraph_update_background_paint(
        paragraph: *mut tl_paragraph_t,
        from: usize,
        to: usize,
        cpaint: *const sk_paint_t,
    );
    pub fn tl_paragraph_get_path(
        paragraph: *mut tl_paragraph_t,
        line_number: ::std::os::raw::c_int,
        dest: *mut sk_path_t,
    ) -> ::std::os::raw::c_int;
    pub fn tl_paragraph_get_path_text_blob(blob: *mut sk_textblob_t) -> *mut sk_path_t;
    pub fn tl_paragraph_contains_emoji(
        paragraph: *mut tl_paragraph_t,
        blob: *mut sk_textblob_t,
    ) -> bool;
    pub fn tl_paragraph_contains_color_font_or_bitmap(
        paragraph: *mut tl_paragraph_t,
        blob: *mut sk_textblob_t,
    ) -> bool;
    pub fn tl_paragraph_get_line_number_at(
        paragraph: *mut tl_paragraph_t,
        index: usize,
    ) -> ::std::os::raw::c_int;
    pub fn tl_paragraph_get_actual_text_range(
        paragraph: *mut tl_paragraph_t,
        line_number: ::std::os::raw::c_int,
        include_spaces: bool,
        start: *mut usize,
        end: *mut usize,
    );
    pub fn sk_bitmap_destructor(cbitmap: *mut sk_bitmap_t);
    pub fn sk_bitmap_new() -> *mut sk_bitmap_t;
    pub fn sk_bitmap_get_info(cbitmap: *mut sk_bitmap_t, info: *mut sk_imageinfo_t);
    pub fn sk_bitmap_get_pixels(
        cbitmap: *mut sk_bitmap_t,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn sk_bitmap_get_row_bytes(cbitmap: *mut sk_bitmap_t) -> usize;
    pub fn sk_bitmap_get_byte_count(cbitmap: *mut sk_bitmap_t) -> usize;
    pub fn sk_bitmap_reset(cbitmap: *mut sk_bitmap_t);
    pub fn sk_bitmap_is_null(cbitmap: *mut sk_bitmap_t) -> bool;
    pub fn sk_bitmap_is_immutable(cbitmap: *mut sk_bitmap_t) -> bool;
    pub fn sk_bitmap_set_immutable(cbitmap: *mut sk_bitmap_t);
    pub fn sk_bitmap_erase(cbitmap: *mut sk_bitmap_t, color: sk_color_t);
    pub fn sk_bitmap_erase_rect(
        cbitmap: *mut sk_bitmap_t,
        color: sk_color_t,
        rect: *mut sk_irect_t,
    );
    pub fn sk_bitmap_get_addr_8(
        cbitmap: *mut sk_bitmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut u8;
    pub fn sk_bitmap_get_addr_16(
        cbitmap: *mut sk_bitmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut u16;
    pub fn sk_bitmap_get_addr_32(
        cbitmap: *mut sk_bitmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut u32;
    pub fn sk_bitmap_get_addr(
        cbitmap: *mut sk_bitmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn sk_bitmap_get_pixel_color(
        cbitmap: *mut sk_bitmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> sk_color_t;
    pub fn sk_bitmap_ready_to_draw(cbitmap: *mut sk_bitmap_t) -> bool;
    pub fn sk_bitmap_get_pixel_colors(cbitmap: *mut sk_bitmap_t, colors: *mut sk_color_t);
    pub fn sk_bitmap_install_pixels(
        cbitmap: *mut sk_bitmap_t,
        cinfo: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        releaseProc: sk_bitmap_release_proc,
        context: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn sk_bitmap_install_pixels_with_pixmap(
        cbitmap: *mut sk_bitmap_t,
        cpixmap: *const sk_pixmap_t,
    ) -> bool;
    pub fn sk_bitmap_try_alloc_pixels(
        cbitmap: *mut sk_bitmap_t,
        requestedInfo: *const sk_imageinfo_t,
        rowBytes: usize,
    ) -> bool;
    pub fn sk_bitmap_try_alloc_pixels_with_flags(
        cbitmap: *mut sk_bitmap_t,
        requestedInfo: *const sk_imageinfo_t,
        flags: u32,
    ) -> bool;
    pub fn sk_bitmap_set_pixels(cbitmap: *mut sk_bitmap_t, pixels: *mut ::std::os::raw::c_void);
    pub fn sk_bitmap_peek_pixels(cbitmap: *mut sk_bitmap_t, cpixmap: *mut sk_pixmap_t) -> bool;
    pub fn sk_bitmap_extract_subset(
        cbitmap: *mut sk_bitmap_t,
        dst: *mut sk_bitmap_t,
        subset: *mut sk_irect_t,
    ) -> bool;
    pub fn sk_bitmap_extract_alpha(
        cbitmap: *mut sk_bitmap_t,
        dst: *mut sk_bitmap_t,
        paint: *const sk_paint_t,
        offset: *mut sk_ipoint_t,
    ) -> bool;
    pub fn sk_bitmap_notify_pixels_changed(cbitmap: *mut sk_bitmap_t);
    pub fn sk_bitmap_swap(cbitmap: *mut sk_bitmap_t, cother: *mut sk_bitmap_t);
    pub fn sk_bitmap_make_shader(
        cbitmap: *mut sk_bitmap_t,
        tmx: sk_shader_tilemode_t,
        tmy: sk_shader_tilemode_t,
        sampling: *mut sk_sampling_options_t,
        cmatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_canvas_destroy(ccanvas: *mut sk_canvas_t);
    pub fn sk_canvas_clear(ccanvas: *mut sk_canvas_t, color: sk_color_t);
    pub fn sk_canvas_clear_color4f(ccanvas: *mut sk_canvas_t, color: sk_color4f_t);
    pub fn sk_canvas_discard(ccanvas: *mut sk_canvas_t);
    pub fn sk_canvas_get_save_count(ccanvas: *mut sk_canvas_t) -> ::std::os::raw::c_int;
    pub fn sk_canvas_restore_to_count(ccanvas: *mut sk_canvas_t, saveCount: ::std::os::raw::c_int);
    pub fn sk_canvas_draw_color(
        ccanvas: *mut sk_canvas_t,
        color: sk_color_t,
        cmode: sk_blendmode_t,
    );
    pub fn sk_canvas_draw_color4f(
        ccanvas: *mut sk_canvas_t,
        color: sk_color4f_t,
        cmode: sk_blendmode_t,
    );
    pub fn sk_canvas_draw_points(
        ccanvas: *mut sk_canvas_t,
        pointMode: sk_point_mode_t,
        count: usize,
        points: *const sk_point_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_point(
        ccanvas: *mut sk_canvas_t,
        x: f32,
        y: f32,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_line(
        ccanvas: *mut sk_canvas_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        cpaint: *mut sk_paint_t,
    );
    pub fn sk_canvas_draw_simple_text(
        ccanvas: *mut sk_canvas_t,
        text: *const ::std::os::raw::c_void,
        byte_length: usize,
        encoding: sk_text_encoding_t,
        x: f32,
        y: f32,
        cfont: *const sk_font_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_text_blob(
        ccanvas: *mut sk_canvas_t,
        text: *mut sk_textblob_t,
        x: f32,
        y: f32,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_reset_matrix(ccanvas: *mut sk_canvas_t);
    pub fn sk_canvas_set_matrix(ccanvas: *mut sk_canvas_t, cmatrix: *const sk_matrix44_t);
    pub fn sk_canvas_get_matrix(ccanvas: *mut sk_canvas_t, cmatrix: *mut sk_matrix44_t);
    pub fn sk_canvas_draw_round_rect(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        rx: f32,
        ry: f32,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_clip_rect_with_operation(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        op: sk_clipop_t,
        doAA: bool,
    );
    pub fn sk_canvas_clip_path_with_operation(
        ccanvas: *mut sk_canvas_t,
        cpath: *const sk_path_t,
        op: sk_clipop_t,
        doAA: bool,
    );
    pub fn sk_canvas_clip_rrect_with_operation(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rrect_t,
        op: sk_clipop_t,
        doAA: bool,
    );
    pub fn sk_canvas_get_local_clip_bounds(
        ccanvas: *mut sk_canvas_t,
        cbounds: *mut sk_rect_t,
    ) -> bool;
    pub fn sk_canvas_get_device_clip_bounds(
        ccanvas: *mut sk_canvas_t,
        cbounds: *mut sk_irect_t,
    ) -> bool;
    pub fn sk_canvas_save(ccanvas: *mut sk_canvas_t) -> ::std::os::raw::c_int;
    pub fn sk_canvas_save_layer(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        cpaint: *const sk_paint_t,
    ) -> ::std::os::raw::c_int;
    pub fn sk_canvas_restore(ccanvas: *mut sk_canvas_t);
    pub fn sk_canvas_translate(ccanvas: *mut sk_canvas_t, dx: f32, dy: f32);
    pub fn sk_canvas_scale(ccanvas: *mut sk_canvas_t, sx: f32, sy: f32);
    pub fn sk_canvas_rotate_degrees(ccanvas: *mut sk_canvas_t, degrees: f32);
    pub fn sk_canvas_rotate_radians(ccanvas: *mut sk_canvas_t, radians: f32);
    pub fn sk_canvas_skew(ccanvas: *mut sk_canvas_t, sx: f32, sy: f32);
    pub fn sk_canvas_concat(ccanvas: *mut sk_canvas_t, cmatrix: *const sk_matrix44_t);
    pub fn sk_canvas_quick_reject(ccanvas: *mut sk_canvas_t, crect: *const sk_rect_t) -> bool;
    pub fn sk_canvas_clip_region(
        ccanvas: *mut sk_canvas_t,
        region: *const sk_region_t,
        op: sk_clipop_t,
    );
    pub fn sk_canvas_draw_paint(ccanvas: *mut sk_canvas_t, cpaint: *const sk_paint_t);
    pub fn sk_canvas_draw_region(
        ccanvas: *mut sk_canvas_t,
        cregion: *const sk_region_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_rect(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_rrect(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rrect_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_circle(
        ccanvas: *mut sk_canvas_t,
        cx: f32,
        cy: f32,
        rad: f32,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_oval(
        ccanvas: *mut sk_canvas_t,
        crect: *const sk_rect_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_path(
        ccanvas: *mut sk_canvas_t,
        cpath: *const sk_path_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_image(
        ccanvas: *mut sk_canvas_t,
        cimage: *const sk_image_t,
        x: f32,
        y: f32,
        sampling: *const sk_sampling_options_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_image_rect(
        ccanvas: *mut sk_canvas_t,
        cimage: *const sk_image_t,
        csrcR: *const sk_rect_t,
        cdstR: *const sk_rect_t,
        sampling: *const sk_sampling_options_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_picture(
        ccanvas: *mut sk_canvas_t,
        cpicture: *const sk_picture_t,
        cmatrix: *const sk_matrix_t,
        cpaint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_drawable(
        ccanvas: *mut sk_canvas_t,
        cdrawable: *mut sk_drawable_t,
        cmatrix: *const sk_matrix_t,
    );
    pub fn sk_canvas_flush(ccanvas: *mut sk_canvas_t);
    pub fn sk_canvas_new_from_bitmap(bitmap: *const sk_bitmap_t) -> *mut sk_canvas_t;
    pub fn sk_canvas_new_from_raster(
        cinfo: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_canvas_t;
    pub fn sk_canvas_draw_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        key: *const ::std::os::raw::c_char,
        value: *mut sk_data_t,
    );
    pub fn sk_canvas_draw_url_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        value: *mut sk_data_t,
    );
    pub fn sk_canvas_draw_named_destination_annotation(
        t: *mut sk_canvas_t,
        point: *const sk_point_t,
        value: *mut sk_data_t,
    );
    pub fn sk_canvas_draw_link_destination_annotation(
        t: *mut sk_canvas_t,
        rect: *const sk_rect_t,
        value: *mut sk_data_t,
    );
    pub fn sk_canvas_draw_image_lattice(
        ccanvas: *mut sk_canvas_t,
        image: *const sk_image_t,
        lattice: *const sk_lattice_t,
        dst: *const sk_rect_t,
        mode: sk_filter_mode_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_image_nine(
        ccanvas: *mut sk_canvas_t,
        image: *const sk_image_t,
        center: *const sk_irect_t,
        dst: *const sk_rect_t,
        mode: sk_filter_mode_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_vertices(
        ccanvas: *mut sk_canvas_t,
        vertices: *const sk_vertices_t,
        mode: sk_blendmode_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_arc(
        ccanvas: *mut sk_canvas_t,
        oval: *const sk_rect_t,
        startAngle: f32,
        sweepAngle: f32,
        useCenter: bool,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_drrect(
        ccanvas: *mut sk_canvas_t,
        outer: *const sk_rrect_t,
        inner: *const sk_rrect_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_atlas(
        ccanvas: *mut sk_canvas_t,
        atlas: *const sk_image_t,
        xform: *const sk_rsxform_t,
        tex: *const sk_rect_t,
        colors: *const sk_color_t,
        count: ::std::os::raw::c_int,
        mode: sk_blendmode_t,
        sampling: *const sk_sampling_options_t,
        cullRect: *const sk_rect_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_draw_patch(
        ccanvas: *mut sk_canvas_t,
        cubics: *const sk_point_t,
        colors: *const sk_color_t,
        texCoords: *const sk_point_t,
        mode: sk_blendmode_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_canvas_is_clip_empty(ccanvas: *mut sk_canvas_t) -> bool;
    pub fn sk_canvas_is_clip_rect(ccanvas: *mut sk_canvas_t) -> bool;
    pub fn sk_nodraw_canvas_new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_nodraw_canvas_t;
    pub fn sk_nodraw_canvas_destroy(t: *mut sk_nodraw_canvas_t);
    pub fn sk_nway_canvas_new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_nway_canvas_t;
    pub fn sk_nway_canvas_destroy(t: *mut sk_nway_canvas_t);
    pub fn sk_nway_canvas_add_canvas(t: *mut sk_nway_canvas_t, canvas: *mut sk_canvas_t);
    pub fn sk_nway_canvas_remove_canvas(t: *mut sk_nway_canvas_t, canvas: *mut sk_canvas_t);
    pub fn sk_nway_canvas_remove_all(t: *mut sk_nway_canvas_t);
    pub fn sk_overdraw_canvas_new(canvas: *mut sk_canvas_t) -> *mut sk_overdraw_canvas_t;
    pub fn sk_overdraw_canvas_destroy(canvas: *mut sk_overdraw_canvas_t);
    pub fn sk_codec_min_buffered_bytes_needed() -> usize;
    pub fn sk_codec_new_from_stream(
        stream: *mut sk_stream_t,
        result: *mut sk_codec_result_t,
    ) -> *mut sk_codec_t;
    pub fn sk_codec_new_from_data(data: *mut sk_data_t) -> *mut sk_codec_t;
    pub fn sk_codec_destroy(codec: *mut sk_codec_t);
    pub fn sk_codec_get_info(codec: *mut sk_codec_t, info: *mut sk_imageinfo_t);
    pub fn sk_codec_get_origin(codec: *mut sk_codec_t) -> sk_encodedorigin_t;
    pub fn sk_codec_get_scaled_dimensions(
        codec: *mut sk_codec_t,
        desiredScale: f32,
        dimensions: *mut sk_isize_t,
    );
    pub fn sk_codec_get_valid_subset(
        codec: *mut sk_codec_t,
        desiredSubset: *mut sk_irect_t,
    ) -> bool;
    pub fn sk_codec_get_encoded_format(codec: *mut sk_codec_t) -> sk_encoded_image_format_t;
    pub fn sk_codec_get_pixels(
        codec: *mut sk_codec_t,
        info: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        options: *const sk_codec_options_t,
    ) -> sk_codec_result_t;
    pub fn sk_codec_start_incremental_decode(
        codec: *mut sk_codec_t,
        info: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        options: *const sk_codec_options_t,
    ) -> sk_codec_result_t;
    pub fn sk_codec_incremental_decode(
        codec: *mut sk_codec_t,
        rowsDecoded: *mut ::std::os::raw::c_int,
    ) -> sk_codec_result_t;
    pub fn sk_codec_start_scanline_decode(
        codec: *mut sk_codec_t,
        info: *const sk_imageinfo_t,
        options: *const sk_codec_options_t,
    ) -> sk_codec_result_t;
    pub fn sk_codec_get_scanlines(
        codec: *mut sk_codec_t,
        dst: *mut ::std::os::raw::c_void,
        countLines: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> ::std::os::raw::c_int;
    pub fn sk_codec_skip_scanlines(
        codec: *mut sk_codec_t,
        countLines: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_codec_get_scanline_order(codec: *mut sk_codec_t) -> sk_codec_scanline_order_t;
    pub fn sk_codec_next_scanline(codec: *mut sk_codec_t) -> ::std::os::raw::c_int;
    pub fn sk_codec_output_scanline(
        codec: *mut sk_codec_t,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sk_codec_get_frame_count(codec: *mut sk_codec_t) -> ::std::os::raw::c_int;
    pub fn sk_codec_get_frame_info(codec: *mut sk_codec_t, frameInfo: *mut sk_codec_frameinfo_t);
    pub fn sk_codec_get_frame_info_for_index(
        codec: *mut sk_codec_t,
        index: ::std::os::raw::c_int,
        frameInfo: *mut sk_codec_frameinfo_t,
    ) -> bool;
    pub fn sk_codec_get_repetition_count(codec: *mut sk_codec_t) -> ::std::os::raw::c_int;
    pub fn sk_colorfilter_unref(filter: *mut sk_colorfilter_t);
    pub fn sk_colorfilter_new_mode(c: sk_color_t, mode: sk_blendmode_t) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_lighting(mul: sk_color_t, add: sk_color_t) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_compose(
        outer: *mut sk_colorfilter_t,
        inner: *mut sk_colorfilter_t,
    ) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_color_matrix(array: *const f32) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_luma_color() -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_high_contrast(
        config: *const sk_highcontrastconfig_t,
    ) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_table(table: *const u8) -> *mut sk_colorfilter_t;
    pub fn sk_colorfilter_new_table_argb(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> *mut sk_colorfilter_t;
    pub fn sk_colorspace_ref(colorspace: *mut sk_colorspace_t);
    pub fn sk_colorspace_unref(colorspace: *mut sk_colorspace_t);
    pub fn sk_colorspace_new_srgb() -> *mut sk_colorspace_t;
    pub fn sk_colorspace_new_srgb_linear() -> *mut sk_colorspace_t;
    pub fn sk_colorspace_new_rgb(
        transferFn: *const sk_colorspace_transfer_fn_t,
        toXYZD50: *const sk_colorspace_xyz_t,
    ) -> *mut sk_colorspace_t;
    pub fn sk_colorspace_new_icc(
        profile: *const sk_colorspace_icc_profile_t,
    ) -> *mut sk_colorspace_t;
    pub fn sk_colorspace_to_profile(
        colorspace: *const sk_colorspace_t,
        profile: *mut sk_colorspace_icc_profile_t,
    );
    pub fn sk_colorspace_gamma_close_to_srgb(colorspace: *const sk_colorspace_t) -> bool;
    pub fn sk_colorspace_gamma_is_linear(colorspace: *const sk_colorspace_t) -> bool;
    pub fn sk_colorspace_is_numerical_transfer_fn(
        colorspace: *const sk_colorspace_t,
        transferFn: *mut sk_colorspace_transfer_fn_t,
    ) -> bool;
    pub fn sk_colorspace_to_xyzd50(
        colorspace: *const sk_colorspace_t,
        toXYZD50: *mut sk_colorspace_xyz_t,
    ) -> bool;
    pub fn sk_colorspace_make_linear_gamma(
        colorspace: *const sk_colorspace_t,
    ) -> *mut sk_colorspace_t;
    pub fn sk_colorspace_make_srgb_gamma(
        colorspace: *const sk_colorspace_t,
    ) -> *mut sk_colorspace_t;
    pub fn sk_colorspace_is_srgb(colorspace: *const sk_colorspace_t) -> bool;
    pub fn sk_colorspace_equals(src: *const sk_colorspace_t, dst: *const sk_colorspace_t) -> bool;
    pub fn sk_colorspace_transfer_fn_named_srgb(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_named_2dot2(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_named_linear(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_named_rec2020(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_named_pq(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_named_hlg(transferFn: *mut sk_colorspace_transfer_fn_t);
    pub fn sk_colorspace_transfer_fn_eval(
        transferFn: *const sk_colorspace_transfer_fn_t,
        x: f32,
    ) -> f32;
    pub fn sk_colorspace_transfer_fn_invert(
        src: *const sk_colorspace_transfer_fn_t,
        dst: *mut sk_colorspace_transfer_fn_t,
    ) -> bool;
    pub fn sk_colorspace_primaries_to_xyzd50(
        primaries: *const sk_colorspace_primaries_t,
        toXYZD50: *mut sk_colorspace_xyz_t,
    ) -> bool;
    pub fn sk_colorspace_xyz_named_srgb(xyz: *mut sk_colorspace_xyz_t);
    pub fn sk_colorspace_xyz_named_adobe_rgb(xyz: *mut sk_colorspace_xyz_t);
    pub fn sk_colorspace_xyz_named_display_p3(xyz: *mut sk_colorspace_xyz_t);
    pub fn sk_colorspace_xyz_named_rec2020(xyz: *mut sk_colorspace_xyz_t);
    pub fn sk_colorspace_xyz_named_xyz(xyz: *mut sk_colorspace_xyz_t);
    pub fn sk_colorspace_xyz_invert(
        src: *const sk_colorspace_xyz_t,
        dst: *mut sk_colorspace_xyz_t,
    ) -> bool;
    pub fn sk_colorspace_xyz_concat(
        a: *const sk_colorspace_xyz_t,
        b: *const sk_colorspace_xyz_t,
        result: *mut sk_colorspace_xyz_t,
    );
    pub fn sk_colorspace_icc_profile_delete(profile: *mut sk_colorspace_icc_profile_t);
    pub fn sk_colorspace_icc_profile_new() -> *mut sk_colorspace_icc_profile_t;
    pub fn sk_colorspace_icc_profile_parse(
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        profile: *mut sk_colorspace_icc_profile_t,
    ) -> bool;
    pub fn sk_colorspace_icc_profile_get_buffer(
        profile: *const sk_colorspace_icc_profile_t,
        size: *mut u32,
    ) -> *const u8;
    pub fn sk_colorspace_icc_profile_get_to_xyzd50(
        profile: *const sk_colorspace_icc_profile_t,
        toXYZD50: *mut sk_colorspace_xyz_t,
    ) -> bool;
    pub fn sk_color4f_to_color(color4f: *const sk_color4f_t) -> sk_color_t;
    pub fn sk_color4f_from_color(color: sk_color_t, color4f: *mut sk_color4f_t);
    pub fn sk_data_new_empty() -> *mut sk_data_t;
    pub fn sk_data_new_with_copy(
        src: *const ::std::os::raw::c_void,
        length: usize,
    ) -> *mut sk_data_t;
    pub fn sk_data_new_subset(
        src: *const sk_data_t,
        offset: usize,
        length: usize,
    ) -> *mut sk_data_t;
    pub fn sk_data_ref(arg1: *const sk_data_t);
    pub fn sk_data_unref(arg1: *const sk_data_t);
    pub fn sk_data_get_size(arg1: *const sk_data_t) -> usize;
    pub fn sk_data_get_data(arg1: *const sk_data_t) -> *const ::std::os::raw::c_void;
    pub fn sk_data_new_from_file(path: *const ::std::os::raw::c_char) -> *mut sk_data_t;
    pub fn sk_data_new_from_stream(stream: *mut sk_stream_t, length: usize) -> *mut sk_data_t;
    pub fn sk_data_get_bytes(arg1: *const sk_data_t) -> *const u8;
    pub fn sk_data_new_with_proc(
        ptr: *const ::std::os::raw::c_void,
        length: usize,
        proc_: sk_data_release_proc,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut sk_data_t;
    pub fn sk_data_new_uninitialized(size: usize) -> *mut sk_data_t;
    pub fn sk_document_unref(document: *mut sk_document_t);
    pub fn sk_document_create_pdf_from_stream(stream: *mut sk_wstream_t) -> *mut sk_document_t;
    pub fn sk_document_create_pdf_from_stream_with_metadata(
        stream: *mut sk_wstream_t,
        metadata: *const sk_document_pdf_metadata_t,
    ) -> *mut sk_document_t;
    pub fn sk_document_create_xps_from_stream(
        stream: *mut sk_wstream_t,
        dpi: f32,
    ) -> *mut sk_document_t;
    pub fn sk_document_begin_page(
        document: *mut sk_document_t,
        width: f32,
        height: f32,
        content: *const sk_rect_t,
    ) -> *mut sk_canvas_t;
    pub fn sk_document_end_page(document: *mut sk_document_t);
    pub fn sk_document_close(document: *mut sk_document_t);
    pub fn sk_document_abort(document: *mut sk_document_t);
    pub fn sk_drawable_unref(arg1: *mut sk_drawable_t);
    pub fn sk_drawable_get_generation_id(arg1: *mut sk_drawable_t) -> u32;
    pub fn sk_drawable_get_bounds(arg1: *mut sk_drawable_t, arg2: *mut sk_rect_t);
    pub fn sk_drawable_draw(
        arg1: *mut sk_drawable_t,
        arg2: *mut sk_canvas_t,
        arg3: *const sk_matrix_t,
    );
    pub fn sk_drawable_new_picture_snapshot(arg1: *mut sk_drawable_t) -> *mut sk_picture_t;
    pub fn sk_drawable_notify_drawing_changed(arg1: *mut sk_drawable_t);
    pub fn sk_font_new() -> *mut sk_font_t;
    pub fn sk_font_new_with_values(
        typeface: *mut sk_typeface_t,
        size: f32,
        scaleX: f32,
        skewX: f32,
    ) -> *mut sk_font_t;
    pub fn sk_font_delete(font: *mut sk_font_t);
    pub fn sk_font_is_force_auto_hinting(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_force_auto_hinting(font: *mut sk_font_t, value: bool);
    pub fn sk_font_is_embedded_bitmaps(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_embedded_bitmaps(font: *mut sk_font_t, value: bool);
    pub fn sk_font_is_subpixel(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_subpixel(font: *mut sk_font_t, value: bool);
    pub fn sk_font_is_linear_metrics(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_linear_metrics(font: *mut sk_font_t, value: bool);
    pub fn sk_font_is_embolden(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_embolden(font: *mut sk_font_t, value: bool);
    pub fn sk_font_is_baseline_snap(font: *const sk_font_t) -> bool;
    pub fn sk_font_set_baseline_snap(font: *mut sk_font_t, value: bool);
    pub fn sk_font_get_edging(font: *const sk_font_t) -> sk_font_edging_t;
    pub fn sk_font_set_edging(font: *mut sk_font_t, value: sk_font_edging_t);
    pub fn sk_font_get_hinting(font: *const sk_font_t) -> sk_font_hinting_t;
    pub fn sk_font_set_hinting(font: *mut sk_font_t, value: sk_font_hinting_t);
    pub fn sk_font_get_typeface(font: *const sk_font_t) -> *mut sk_typeface_t;
    pub fn sk_font_set_typeface(font: *mut sk_font_t, value: *mut sk_typeface_t);
    pub fn sk_font_get_size(font: *const sk_font_t) -> f32;
    pub fn sk_font_set_size(font: *mut sk_font_t, value: f32);
    pub fn sk_font_get_scale_x(font: *const sk_font_t) -> f32;
    pub fn sk_font_set_scale_x(font: *mut sk_font_t, value: f32);
    pub fn sk_font_get_skew_x(font: *const sk_font_t) -> f32;
    pub fn sk_font_set_skew_x(font: *mut sk_font_t, value: f32);
    pub fn sk_font_text_to_glyphs(
        font: *const sk_font_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        encoding: sk_text_encoding_t,
        glyphs: *mut u16,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sk_font_unichar_to_glyph(font: *const sk_font_t, uni: i32) -> u16;
    pub fn sk_font_unichars_to_glyphs(
        font: *const sk_font_t,
        uni: *const i32,
        count: ::std::os::raw::c_int,
        glyphs: *mut u16,
    );
    pub fn sk_font_measure_text(
        font: *const sk_font_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        encoding: sk_text_encoding_t,
        bounds: *mut sk_rect_t,
        paint: *const sk_paint_t,
    ) -> f32;
    pub fn sk_font_measure_text_no_return(
        font: *const sk_font_t,
        text: *const ::std::os::raw::c_void,
        byteLength: usize,
        encoding: sk_text_encoding_t,
        bounds: *mut sk_rect_t,
        paint: *const sk_paint_t,
        measuredWidth: *mut f32,
    );
    pub fn sk_font_get_widths_bounds(
        font: *const sk_font_t,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        widths: *mut f32,
        bounds: *mut sk_rect_t,
        paint: *const sk_paint_t,
    );
    pub fn sk_font_get_pos(
        font: *const sk_font_t,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        pos: *mut sk_point_t,
        origin: *mut sk_point_t,
    );
    pub fn sk_font_get_xpos(
        font: *const sk_font_t,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        xpos: *mut f32,
        origin: f32,
    );
    pub fn sk_font_get_intercepts(
        font: *const sk_font_t,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        pos: *const sk_point_t,
        top: f32,
        bottom: f32,
        cpaint_or_null: *const sk_paint_t,
        result_or_null: *mut f32,
        result_len: usize,
    ) -> usize;
    pub fn sk_font_get_path(font: *const sk_font_t, glyph: u16, path: *mut sk_path_t) -> bool;
    pub fn sk_font_get_paths(
        font: *const sk_font_t,
        glyphs: *mut u16,
        count: ::std::os::raw::c_int,
        glyphPathProc: sk_glyph_path_proc,
        context: *mut ::std::os::raw::c_void,
    );
    pub fn sk_font_get_metrics(font: *const sk_font_t, metrics: *mut sk_fontmetrics_t) -> f32;
    pub fn sk_text_utils_get_path(
        text: *const ::std::os::raw::c_void,
        length: usize,
        encoding: sk_text_encoding_t,
        x: f32,
        y: f32,
        font: *const sk_font_t,
        path: *mut sk_path_t,
    );
    pub fn sk_refcnt_unique(refcnt: *const sk_refcnt_t) -> bool;
    pub fn sk_refcnt_safe_ref(refcnt: *mut sk_refcnt_t);
    pub fn sk_refcnt_safe_unref(refcnt: *mut sk_refcnt_t);
    pub fn sk_nvrefcnt_unique(refcnt: *const sk_nvrefcnt_t) -> bool;
    pub fn sk_nvrefcnt_safe_ref(refcnt: *mut sk_nvrefcnt_t);
    pub fn sk_nvrefcnt_safe_unref(refcnt: *mut sk_nvrefcnt_t);
    pub fn sk_colortype_get_default_8888() -> sk_colortype_t;
    pub fn sk_version_get_milestone() -> ::std::os::raw::c_int;
    pub fn sk_version_get_increment() -> ::std::os::raw::c_int;
    pub fn sk_version_get_string() -> *const ::std::os::raw::c_char;
    pub fn sk_graphics_init();
    pub fn sk_graphics_purge_font_cache();
    pub fn sk_graphics_purge_resource_cache();
    pub fn sk_graphics_purge_all_caches();
    pub fn sk_graphics_get_font_cache_used() -> usize;
    pub fn sk_graphics_get_font_cache_limit() -> usize;
    pub fn sk_graphics_set_font_cache_limit(bytes: usize) -> usize;
    pub fn sk_graphics_get_font_cache_count_used() -> ::std::os::raw::c_int;
    pub fn sk_graphics_get_font_cache_count_limit() -> ::std::os::raw::c_int;
    pub fn sk_graphics_set_font_cache_count_limit(
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sk_graphics_get_resource_cache_total_bytes_used() -> usize;
    pub fn sk_graphics_get_resource_cache_total_byte_limit() -> usize;
    pub fn sk_graphics_set_resource_cache_total_byte_limit(newLimit: usize) -> usize;
    pub fn sk_graphics_get_resource_cache_single_allocation_byte_limit() -> usize;
    pub fn sk_graphics_set_resource_cache_single_allocation_byte_limit(newLimit: usize) -> usize;
    pub fn sk_graphics_dump_memory_statistics(dump: *mut sk_tracememorydump_t);
    pub fn sk_image_ref(cimage: *const sk_image_t);
    pub fn sk_image_unref(cimage: *const sk_image_t);
    pub fn sk_image_new_raster_copy(
        cinfo: *const sk_imageinfo_t,
        pixels: *const ::std::os::raw::c_void,
        rowBytes: usize,
    ) -> *mut sk_image_t;
    pub fn sk_image_new_raster_copy_with_pixmap(pixmap: *const sk_pixmap_t) -> *mut sk_image_t;
    pub fn sk_image_new_raster_data(
        cinfo: *const sk_imageinfo_t,
        pixels: *mut sk_data_t,
        rowBytes: usize,
    ) -> *mut sk_image_t;
    pub fn sk_image_new_raster(
        pixmap: *const sk_pixmap_t,
        releaseProc: sk_image_raster_release_proc,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut sk_image_t;
    pub fn sk_image_new_from_bitmap(cbitmap: *const sk_bitmap_t) -> *mut sk_image_t;
    pub fn sk_image_new_from_encoded(cdata: *const sk_data_t) -> *mut sk_image_t;
    pub fn sk_image_new_from_texture(
        context: *mut gr_recording_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        alpha: sk_alphatype_t,
        colorSpace: *const sk_colorspace_t,
        releaseProc: sk_image_texture_release_proc,
        releaseContext: *mut ::std::os::raw::c_void,
    ) -> *mut sk_image_t;
    pub fn sk_image_new_from_adopted_texture(
        context: *mut gr_recording_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        alpha: sk_alphatype_t,
        colorSpace: *const sk_colorspace_t,
    ) -> *mut sk_image_t;
    pub fn sk_image_new_from_picture(
        picture: *mut sk_picture_t,
        dimensions: *const sk_isize_t,
        cmatrix: *const sk_matrix_t,
        paint: *const sk_paint_t,
        useFloatingPointBitDepth: bool,
        colorSpace: *const sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_image_t;
    pub fn sk_image_get_width(cimage: *const sk_image_t) -> ::std::os::raw::c_int;
    pub fn sk_image_get_height(cimage: *const sk_image_t) -> ::std::os::raw::c_int;
    pub fn sk_image_get_unique_id(cimage: *const sk_image_t) -> u32;
    pub fn sk_image_get_alpha_type(image: *const sk_image_t) -> sk_alphatype_t;
    pub fn sk_image_get_color_type(image: *const sk_image_t) -> sk_colortype_t;
    pub fn sk_image_get_colorspace(image: *const sk_image_t) -> *mut sk_colorspace_t;
    pub fn sk_image_is_alpha_only(image: *const sk_image_t) -> bool;
    pub fn sk_image_make_shader(
        image: *const sk_image_t,
        tileX: sk_shader_tilemode_t,
        tileY: sk_shader_tilemode_t,
        sampling: *const sk_sampling_options_t,
        cmatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_image_peek_pixels(image: *const sk_image_t, pixmap: *mut sk_pixmap_t) -> bool;
    pub fn sk_image_is_texture_backed(image: *const sk_image_t) -> bool;
    pub fn sk_image_is_lazy_generated(image: *const sk_image_t) -> bool;
    pub fn sk_image_is_valid(
        image: *const sk_image_t,
        context: *mut gr_recording_context_t,
    ) -> bool;
    pub fn sk_image_read_pixels(
        image: *const sk_image_t,
        dstInfo: *const sk_imageinfo_t,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
    pub fn sk_image_read_pixels_into_pixmap(
        image: *const sk_image_t,
        dst: *const sk_pixmap_t,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
    pub fn sk_image_scale_pixels(
        image: *const sk_image_t,
        dst: *const sk_pixmap_t,
        sampling: *const sk_sampling_options_t,
        cachingHint: sk_image_caching_hint_t,
    ) -> bool;
    pub fn sk_image_ref_encoded(cimage: *const sk_image_t) -> *mut sk_data_t;
    pub fn sk_image_make_subset_raster(
        cimage: *const sk_image_t,
        subset: *const sk_irect_t,
    ) -> *mut sk_image_t;
    pub fn sk_image_make_subset(
        cimage: *const sk_image_t,
        context: *mut gr_direct_context_t,
        subset: *const sk_irect_t,
    ) -> *mut sk_image_t;
    pub fn sk_image_make_texture_image(
        cimage: *const sk_image_t,
        context: *mut gr_direct_context_t,
        mipmapped: bool,
        budgeted: bool,
    ) -> *mut sk_image_t;
    pub fn sk_image_make_non_texture_image(cimage: *const sk_image_t) -> *mut sk_image_t;
    pub fn sk_image_make_raster_image(cimage: *const sk_image_t) -> *mut sk_image_t;
    pub fn sk_image_make_with_filter_raster(
        cimage: *const sk_image_t,
        filter: *const sk_imagefilter_t,
        subset: *const sk_irect_t,
        clipBounds: *const sk_irect_t,
        outSubset: *mut sk_irect_t,
        outOffset: *mut sk_ipoint_t,
    ) -> *mut sk_image_t;
    pub fn sk_image_make_with_filter(
        cimage: *const sk_image_t,
        context: *mut gr_recording_context_t,
        filter: *const sk_imagefilter_t,
        subset: *const sk_irect_t,
        clipBounds: *const sk_irect_t,
        outSubset: *mut sk_irect_t,
        outOffset: *mut sk_ipoint_t,
    ) -> *mut sk_image_t;
    pub fn sk_imagefilter_unref(cfilter: *mut sk_imagefilter_t);
    pub fn sk_imagefilter_new_arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePMColor: bool,
        background: *const sk_imagefilter_t,
        foreground: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_blend(
        mode: sk_blendmode_t,
        background: *const sk_imagefilter_t,
        foreground: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_blur(
        sigmaX: f32,
        sigmaY: f32,
        tileMode: sk_shader_tilemode_t,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_color_filter(
        cf: *mut sk_colorfilter_t,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_compose(
        outer: *const sk_imagefilter_t,
        inner: *const sk_imagefilter_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_displacement_map_effect(
        xChannelSelector: sk_color_channel_t,
        yChannelSelector: sk_color_channel_t,
        scale: f32,
        displacement: *const sk_imagefilter_t,
        color: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_drop_shadow(
        dx: f32,
        dy: f32,
        sigmaX: f32,
        sigmaY: f32,
        color: sk_color_t,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_drop_shadow_only(
        dx: f32,
        dy: f32,
        sigmaX: f32,
        sigmaY: f32,
        color: sk_color_t,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_image(
        image: *mut sk_image_t,
        srcRect: *const sk_rect_t,
        dstRect: *const sk_rect_t,
        sampling: *const sk_sampling_options_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_image_simple(
        image: *mut sk_image_t,
        sampling: *const sk_sampling_options_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_magnifier(
        lensBounds: *const sk_rect_t,
        zoomAmount: f32,
        inset: f32,
        sampling: *const sk_sampling_options_t,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_matrix_convolution(
        kernelSize: *const sk_isize_t,
        kernel: *const f32,
        gain: f32,
        bias: f32,
        kernelOffset: *const sk_ipoint_t,
        ctileMode: sk_shader_tilemode_t,
        convolveAlpha: bool,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_matrix_transform(
        cmatrix: *const sk_matrix_t,
        sampling: *const sk_sampling_options_t,
        input: *const sk_imagefilter_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_merge(
        cfilters: *mut *const sk_imagefilter_t,
        count: ::std::os::raw::c_int,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_merge_simple(
        first: *const sk_imagefilter_t,
        second: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_offset(
        dx: f32,
        dy: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_picture(picture: *const sk_picture_t) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_picture_with_rect(
        picture: *const sk_picture_t,
        targetRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_shader(
        shader: *const sk_shader_t,
        dither: bool,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_tile(
        src: *const sk_rect_t,
        dst: *const sk_rect_t,
        input: *const sk_imagefilter_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_dilate(
        radiusX: f32,
        radiusY: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_erode(
        radiusX: f32,
        radiusY: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_distant_lit_diffuse(
        direction: *const sk_point3_t,
        lightColor: sk_color_t,
        surfaceScale: f32,
        kd: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_point_lit_diffuse(
        location: *const sk_point3_t,
        lightColor: sk_color_t,
        surfaceScale: f32,
        kd: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_spot_lit_diffuse(
        location: *const sk_point3_t,
        target: *const sk_point3_t,
        specularExponent: f32,
        cutoffAngle: f32,
        lightColor: sk_color_t,
        surfaceScale: f32,
        kd: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_distant_lit_specular(
        direction: *const sk_point3_t,
        lightColor: sk_color_t,
        surfaceScale: f32,
        ks: f32,
        shininess: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_point_lit_specular(
        location: *const sk_point3_t,
        lightColor: sk_color_t,
        surfaceScale: f32,
        ks: f32,
        shininess: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_imagefilter_new_spot_lit_specular(
        location: *const sk_point3_t,
        target: *const sk_point3_t,
        specularExponent: f32,
        cutoffAngle: f32,
        lightColor: sk_color_t,
        surfaceScale: f32,
        ks: f32,
        shininess: f32,
        input: *const sk_imagefilter_t,
        cropRect: *const sk_rect_t,
    ) -> *mut sk_imagefilter_t;
    pub fn sk_maskfilter_ref(arg1: *mut sk_maskfilter_t);
    pub fn sk_maskfilter_unref(arg1: *mut sk_maskfilter_t);
    pub fn sk_maskfilter_new_blur(arg1: sk_blurstyle_t, sigma: f32) -> *mut sk_maskfilter_t;
    pub fn sk_maskfilter_new_blur_with_flags(
        arg1: sk_blurstyle_t,
        sigma: f32,
        respectCTM: bool,
    ) -> *mut sk_maskfilter_t;
    pub fn sk_maskfilter_new_table(table: *const u8) -> *mut sk_maskfilter_t;
    pub fn sk_maskfilter_new_gamma(gamma: f32) -> *mut sk_maskfilter_t;
    pub fn sk_maskfilter_new_clip(min: u8, max: u8) -> *mut sk_maskfilter_t;
    pub fn sk_maskfilter_new_shader(cshader: *mut sk_shader_t) -> *mut sk_maskfilter_t;
    pub fn sk_matrix_try_invert(matrix: *mut sk_matrix_t, result: *mut sk_matrix_t) -> bool;
    pub fn sk_matrix_concat(
        result: *mut sk_matrix_t,
        first: *mut sk_matrix_t,
        second: *mut sk_matrix_t,
    );
    pub fn sk_matrix_pre_concat(result: *mut sk_matrix_t, matrix: *mut sk_matrix_t);
    pub fn sk_matrix_post_concat(result: *mut sk_matrix_t, matrix: *mut sk_matrix_t);
    pub fn sk_matrix_map_rect(
        matrix: *mut sk_matrix_t,
        dest: *mut sk_rect_t,
        source: *mut sk_rect_t,
    );
    pub fn sk_matrix_map_points(
        matrix: *mut sk_matrix_t,
        dst: *mut sk_point_t,
        src: *mut sk_point_t,
        count: ::std::os::raw::c_int,
    );
    pub fn sk_matrix_map_vectors(
        matrix: *mut sk_matrix_t,
        dst: *mut sk_point_t,
        src: *mut sk_point_t,
        count: ::std::os::raw::c_int,
    );
    pub fn sk_matrix_map_xy(matrix: *mut sk_matrix_t, x: f32, y: f32, result: *mut sk_point_t);
    pub fn sk_matrix_map_vector(matrix: *mut sk_matrix_t, x: f32, y: f32, result: *mut sk_point_t);
    pub fn sk_matrix_map_radius(matrix: *mut sk_matrix_t, radius: f32) -> f32;
    pub fn sk_paint_new() -> *mut sk_paint_t;
    pub fn sk_paint_clone(arg1: *mut sk_paint_t) -> *mut sk_paint_t;
    pub fn sk_paint_delete(arg1: *mut sk_paint_t);
    pub fn sk_paint_reset(arg1: *mut sk_paint_t);
    pub fn sk_paint_is_antialias(arg1: *const sk_paint_t) -> bool;
    pub fn sk_paint_set_antialias(arg1: *mut sk_paint_t, arg2: bool);
    pub fn sk_paint_get_color(arg1: *const sk_paint_t) -> sk_color_t;
    pub fn sk_paint_get_color4f(paint: *const sk_paint_t, color: *mut sk_color4f_t);
    pub fn sk_paint_set_color(arg1: *mut sk_paint_t, arg2: sk_color_t);
    pub fn sk_paint_set_color4f(
        paint: *mut sk_paint_t,
        color: *mut sk_color4f_t,
        colorspace: *mut sk_colorspace_t,
    );
    pub fn sk_paint_get_style(arg1: *const sk_paint_t) -> sk_paint_style_t;
    pub fn sk_paint_set_style(arg1: *mut sk_paint_t, arg2: sk_paint_style_t);
    pub fn sk_paint_get_stroke_width(arg1: *const sk_paint_t) -> f32;
    pub fn sk_paint_set_stroke_width(arg1: *mut sk_paint_t, width: f32);
    pub fn sk_paint_get_stroke_miter(arg1: *const sk_paint_t) -> f32;
    pub fn sk_paint_set_stroke_miter(arg1: *mut sk_paint_t, miter: f32);
    pub fn sk_paint_get_stroke_cap(arg1: *const sk_paint_t) -> sk_stroke_cap_t;
    pub fn sk_paint_set_stroke_cap(arg1: *mut sk_paint_t, arg2: sk_stroke_cap_t);
    pub fn sk_paint_get_stroke_join(arg1: *const sk_paint_t) -> sk_stroke_join_t;
    pub fn sk_paint_set_stroke_join(arg1: *mut sk_paint_t, arg2: sk_stroke_join_t);
    pub fn sk_paint_set_shader(arg1: *mut sk_paint_t, arg2: *mut sk_shader_t);
    pub fn sk_paint_set_maskfilter(arg1: *mut sk_paint_t, arg2: *mut sk_maskfilter_t);
    pub fn sk_paint_set_blendmode(arg1: *mut sk_paint_t, arg2: sk_blendmode_t);
    pub fn sk_paint_is_dither(arg1: *const sk_paint_t) -> bool;
    pub fn sk_paint_set_dither(arg1: *mut sk_paint_t, arg2: bool);
    pub fn sk_paint_get_shader(arg1: *mut sk_paint_t) -> *mut sk_shader_t;
    pub fn sk_paint_get_maskfilter(arg1: *mut sk_paint_t) -> *mut sk_maskfilter_t;
    pub fn sk_paint_set_colorfilter(arg1: *mut sk_paint_t, arg2: *mut sk_colorfilter_t);
    pub fn sk_paint_get_colorfilter(arg1: *mut sk_paint_t) -> *mut sk_colorfilter_t;
    pub fn sk_paint_set_imagefilter(arg1: *mut sk_paint_t, arg2: *mut sk_imagefilter_t);
    pub fn sk_paint_get_imagefilter(arg1: *mut sk_paint_t) -> *mut sk_imagefilter_t;
    pub fn sk_paint_get_blendmode(arg1: *mut sk_paint_t) -> sk_blendmode_t;
    pub fn sk_paint_get_path_effect(cpaint: *mut sk_paint_t) -> *mut sk_path_effect_t;
    pub fn sk_paint_set_path_effect(cpaint: *mut sk_paint_t, effect: *mut sk_path_effect_t);
    pub fn sk_paint_get_fill_path(
        cpaint: *const sk_paint_t,
        src: *const sk_path_t,
        dst: *mut sk_path_t,
        cullRect: *const sk_rect_t,
        cmatrix: *const sk_matrix_t,
    ) -> bool;
    pub fn sk_path_new() -> *mut sk_path_t;
    pub fn sk_path_delete(arg1: *mut sk_path_t);
    pub fn sk_path_move_to(arg1: *mut sk_path_t, x: f32, y: f32);
    pub fn sk_path_line_to(arg1: *mut sk_path_t, x: f32, y: f32);
    pub fn sk_path_quad_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32, y1: f32);
    pub fn sk_path_conic_to(arg1: *mut sk_path_t, x0: f32, y0: f32, x1: f32, y1: f32, w: f32);
    pub fn sk_path_cubic_to(
        arg1: *mut sk_path_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    );
    pub fn sk_path_arc_to(
        arg1: *mut sk_path_t,
        rx: f32,
        ry: f32,
        xAxisRotate: f32,
        largeArc: sk_path_arc_size_t,
        sweep: sk_path_direction_t,
        x: f32,
        y: f32,
    );
    pub fn sk_path_rarc_to(
        arg1: *mut sk_path_t,
        rx: f32,
        ry: f32,
        xAxisRotate: f32,
        largeArc: sk_path_arc_size_t,
        sweep: sk_path_direction_t,
        x: f32,
        y: f32,
    );
    pub fn sk_path_arc_to_with_oval(
        arg1: *mut sk_path_t,
        oval: *const sk_rect_t,
        startAngle: f32,
        sweepAngle: f32,
        forceMoveTo: bool,
    );
    pub fn sk_path_arc_to_with_points(
        arg1: *mut sk_path_t,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        radius: f32,
    );
    pub fn sk_path_close(arg1: *mut sk_path_t);
    pub fn sk_path_add_rect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: sk_path_direction_t,
    );
    pub fn sk_path_add_rrect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rrect_t,
        arg3: sk_path_direction_t,
    );
    pub fn sk_path_add_rrect_start(
        arg1: *mut sk_path_t,
        arg2: *const sk_rrect_t,
        arg3: sk_path_direction_t,
        arg4: u32,
    );
    pub fn sk_path_add_rounded_rect(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: f32,
        arg4: f32,
        arg5: sk_path_direction_t,
    );
    pub fn sk_path_add_oval(
        arg1: *mut sk_path_t,
        arg2: *const sk_rect_t,
        arg3: sk_path_direction_t,
    );
    pub fn sk_path_add_circle(
        arg1: *mut sk_path_t,
        x: f32,
        y: f32,
        radius: f32,
        dir: sk_path_direction_t,
    );
    pub fn sk_path_get_bounds(arg1: *const sk_path_t, arg2: *mut sk_rect_t);
    pub fn sk_path_compute_tight_bounds(arg1: *const sk_path_t, arg2: *mut sk_rect_t);
    pub fn sk_path_rmove_to(arg1: *mut sk_path_t, dx: f32, dy: f32);
    pub fn sk_path_rline_to(arg1: *mut sk_path_t, dx: f32, yd: f32);
    pub fn sk_path_rquad_to(arg1: *mut sk_path_t, dx0: f32, dy0: f32, dx1: f32, dy1: f32);
    pub fn sk_path_rconic_to(arg1: *mut sk_path_t, dx0: f32, dy0: f32, dx1: f32, dy1: f32, w: f32);
    pub fn sk_path_rcubic_to(
        arg1: *mut sk_path_t,
        dx0: f32,
        dy0: f32,
        dx1: f32,
        dy1: f32,
        dx2: f32,
        dy2: f32,
    );
    pub fn sk_path_add_rect_start(
        cpath: *mut sk_path_t,
        crect: *const sk_rect_t,
        cdir: sk_path_direction_t,
        startIndex: u32,
    );
    pub fn sk_path_add_arc(
        cpath: *mut sk_path_t,
        crect: *const sk_rect_t,
        startAngle: f32,
        sweepAngle: f32,
    );
    pub fn sk_path_get_filltype(arg1: *mut sk_path_t) -> sk_path_filltype_t;
    pub fn sk_path_set_filltype(arg1: *mut sk_path_t, arg2: sk_path_filltype_t);
    pub fn sk_path_transform(cpath: *mut sk_path_t, cmatrix: *const sk_matrix_t);
    pub fn sk_path_transform_to_dest(
        cpath: *const sk_path_t,
        cmatrix: *const sk_matrix_t,
        destination: *mut sk_path_t,
    );
    pub fn sk_path_clone(cpath: *const sk_path_t) -> *mut sk_path_t;
    pub fn sk_path_add_path_offset(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        dx: f32,
        dy: f32,
        add_mode: sk_path_add_mode_t,
    );
    pub fn sk_path_add_path_matrix(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        matrix: *mut sk_matrix_t,
        add_mode: sk_path_add_mode_t,
    );
    pub fn sk_path_add_path(
        cpath: *mut sk_path_t,
        other: *mut sk_path_t,
        add_mode: sk_path_add_mode_t,
    );
    pub fn sk_path_add_path_reverse(cpath: *mut sk_path_t, other: *mut sk_path_t);
    pub fn sk_path_reset(cpath: *mut sk_path_t);
    pub fn sk_path_rewind(cpath: *mut sk_path_t);
    pub fn sk_path_count_points(cpath: *const sk_path_t) -> ::std::os::raw::c_int;
    pub fn sk_path_count_verbs(cpath: *const sk_path_t) -> ::std::os::raw::c_int;
    pub fn sk_path_get_point(
        cpath: *const sk_path_t,
        index: ::std::os::raw::c_int,
        point: *mut sk_point_t,
    );
    pub fn sk_path_get_points(
        cpath: *const sk_path_t,
        points: *mut sk_point_t,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sk_path_contains(cpath: *const sk_path_t, x: f32, y: f32) -> bool;
    pub fn sk_path_parse_svg_string(
        cpath: *mut sk_path_t,
        str_: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn sk_path_to_svg_string(cpath: *const sk_path_t, str_: *mut sk_string_t);
    pub fn sk_path_get_last_point(cpath: *const sk_path_t, point: *mut sk_point_t) -> bool;
    pub fn sk_path_convert_conic_to_quads(
        p0: *const sk_point_t,
        p1: *const sk_point_t,
        p2: *const sk_point_t,
        w: f32,
        pts: *mut sk_point_t,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sk_path_add_poly(
        cpath: *mut sk_path_t,
        points: *const sk_point_t,
        count: ::std::os::raw::c_int,
        close: bool,
    );
    pub fn sk_path_get_segment_masks(cpath: *mut sk_path_t) -> u32;
    pub fn sk_path_is_oval(cpath: *mut sk_path_t, bounds: *mut sk_rect_t) -> bool;
    pub fn sk_path_is_rrect(cpath: *mut sk_path_t, bounds: *mut sk_rrect_t) -> bool;
    pub fn sk_path_is_line(cpath: *mut sk_path_t, line: *mut sk_point_t) -> bool;
    pub fn sk_path_is_rect(
        cpath: *mut sk_path_t,
        rect: *mut sk_rect_t,
        isClosed: *mut bool,
        direction: *mut sk_path_direction_t,
    ) -> bool;
    pub fn sk_path_is_convex(cpath: *const sk_path_t) -> bool;
    pub fn sk_path_create_iter(
        cpath: *mut sk_path_t,
        forceClose: ::std::os::raw::c_int,
    ) -> *mut sk_path_iterator_t;
    pub fn sk_path_iter_next(
        iterator: *mut sk_path_iterator_t,
        points: *mut sk_point_t,
    ) -> sk_path_verb_t;
    pub fn sk_path_iter_conic_weight(iterator: *mut sk_path_iterator_t) -> f32;
    pub fn sk_path_iter_is_close_line(iterator: *mut sk_path_iterator_t) -> ::std::os::raw::c_int;
    pub fn sk_path_iter_is_closed_contour(
        iterator: *mut sk_path_iterator_t,
    ) -> ::std::os::raw::c_int;
    pub fn sk_path_iter_destroy(iterator: *mut sk_path_iterator_t);
    pub fn sk_path_create_rawiter(cpath: *mut sk_path_t) -> *mut sk_path_rawiterator_t;
    pub fn sk_path_rawiter_peek(iterator: *mut sk_path_rawiterator_t) -> sk_path_verb_t;
    pub fn sk_path_rawiter_next(
        iterator: *mut sk_path_rawiterator_t,
        points: *mut sk_point_t,
    ) -> sk_path_verb_t;
    pub fn sk_path_rawiter_conic_weight(iterator: *mut sk_path_rawiterator_t) -> f32;
    pub fn sk_path_rawiter_destroy(iterator: *mut sk_path_rawiterator_t);
    pub fn sk_pathop_op(
        one: *const sk_path_t,
        two: *const sk_path_t,
        op: sk_pathop_t,
        result: *mut sk_path_t,
    ) -> bool;
    pub fn sk_pathop_simplify(path: *const sk_path_t, result: *mut sk_path_t) -> bool;
    pub fn sk_pathop_tight_bounds(path: *const sk_path_t, result: *mut sk_rect_t) -> bool;
    pub fn sk_pathop_as_winding(path: *const sk_path_t, result: *mut sk_path_t) -> bool;
    pub fn sk_opbuilder_new() -> *mut sk_opbuilder_t;
    pub fn sk_opbuilder_destroy(builder: *mut sk_opbuilder_t);
    pub fn sk_opbuilder_add(builder: *mut sk_opbuilder_t, path: *const sk_path_t, op: sk_pathop_t);
    pub fn sk_opbuilder_resolve(builder: *mut sk_opbuilder_t, result: *mut sk_path_t) -> bool;
    pub fn sk_pathmeasure_new() -> *mut sk_pathmeasure_t;
    pub fn sk_pathmeasure_new_with_path(
        path: *const sk_path_t,
        forceClosed: bool,
        resScale: f32,
    ) -> *mut sk_pathmeasure_t;
    pub fn sk_pathmeasure_destroy(pathMeasure: *mut sk_pathmeasure_t);
    pub fn sk_pathmeasure_set_path(
        pathMeasure: *mut sk_pathmeasure_t,
        path: *const sk_path_t,
        forceClosed: bool,
    );
    pub fn sk_pathmeasure_get_length(pathMeasure: *mut sk_pathmeasure_t) -> f32;
    pub fn sk_pathmeasure_get_pos_tan(
        pathMeasure: *mut sk_pathmeasure_t,
        distance: f32,
        position: *mut sk_point_t,
        tangent: *mut sk_vector_t,
    ) -> bool;
    pub fn sk_pathmeasure_get_matrix(
        pathMeasure: *mut sk_pathmeasure_t,
        distance: f32,
        matrix: *mut sk_matrix_t,
        flags: sk_pathmeasure_matrixflags_t,
    ) -> bool;
    pub fn sk_pathmeasure_get_segment(
        pathMeasure: *mut sk_pathmeasure_t,
        start: f32,
        stop: f32,
        dst: *mut sk_path_t,
        startWithMoveTo: bool,
    ) -> bool;
    pub fn sk_pathmeasure_is_closed(pathMeasure: *mut sk_pathmeasure_t) -> bool;
    pub fn sk_pathmeasure_next_contour(pathMeasure: *mut sk_pathmeasure_t) -> bool;
    pub fn sk_path_effect_unref(t: *mut sk_path_effect_t);
    pub fn sk_path_effect_create_compose(
        outer: *mut sk_path_effect_t,
        inner: *mut sk_path_effect_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_sum(
        first: *mut sk_path_effect_t,
        second: *mut sk_path_effect_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_discrete(
        segLength: f32,
        deviation: f32,
        seedAssist: u32,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_corner(radius: f32) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_1d_path(
        path: *const sk_path_t,
        advance: f32,
        phase: f32,
        style: sk_path_effect_1d_style_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_2d_line(
        width: f32,
        matrix: *const sk_matrix_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_2d_path(
        matrix: *const sk_matrix_t,
        path: *const sk_path_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_dash(
        intervals: *const f32,
        count: ::std::os::raw::c_int,
        phase: f32,
    ) -> *mut sk_path_effect_t;
    pub fn sk_path_effect_create_trim(
        start: f32,
        stop: f32,
        mode: sk_path_effect_trim_mode_t,
    ) -> *mut sk_path_effect_t;
    pub fn sk_picture_recorder_new() -> *mut sk_picture_recorder_t;
    pub fn sk_picture_recorder_delete(arg1: *mut sk_picture_recorder_t);
    pub fn sk_picture_recorder_begin_recording(
        arg1: *mut sk_picture_recorder_t,
        arg2: *const sk_rect_t,
    ) -> *mut sk_canvas_t;
    pub fn sk_picture_recorder_end_recording(arg1: *mut sk_picture_recorder_t)
        -> *mut sk_picture_t;
    pub fn sk_picture_recorder_end_recording_as_drawable(
        arg1: *mut sk_picture_recorder_t,
    ) -> *mut sk_drawable_t;
    pub fn sk_picture_get_recording_canvas(crec: *mut sk_picture_recorder_t) -> *mut sk_canvas_t;
    pub fn sk_picture_ref(arg1: *mut sk_picture_t);
    pub fn sk_picture_unref(arg1: *mut sk_picture_t);
    pub fn sk_picture_get_unique_id(arg1: *mut sk_picture_t) -> u32;
    pub fn sk_picture_get_cull_rect(arg1: *mut sk_picture_t, arg2: *mut sk_rect_t);
    pub fn sk_picture_make_shader(
        src: *mut sk_picture_t,
        tmx: sk_shader_tilemode_t,
        tmy: sk_shader_tilemode_t,
        mode: sk_filter_mode_t,
        localMatrix: *const sk_matrix_t,
        tile: *const sk_rect_t,
    ) -> *mut sk_shader_t;
    pub fn sk_picture_serialize_to_data(picture: *const sk_picture_t) -> *mut sk_data_t;
    pub fn sk_picture_serialize_to_stream(picture: *const sk_picture_t, stream: *mut sk_wstream_t);
    pub fn sk_picture_deserialize_from_stream(stream: *mut sk_stream_t) -> *mut sk_picture_t;
    pub fn sk_picture_deserialize_from_data(data: *mut sk_data_t) -> *mut sk_picture_t;
    pub fn sk_picture_deserialize_from_memory(
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> *mut sk_picture_t;
    pub fn sk_pixmap_destructor(cpixmap: *mut sk_pixmap_t);
    pub fn sk_pixmap_new() -> *mut sk_pixmap_t;
    pub fn sk_pixmap_new_with_params(
        cinfo: *const sk_imageinfo_t,
        addr: *const ::std::os::raw::c_void,
        rowBytes: usize,
    ) -> *mut sk_pixmap_t;
    pub fn sk_pixmap_reset(cpixmap: *mut sk_pixmap_t);
    pub fn sk_pixmap_reset_with_params(
        cpixmap: *mut sk_pixmap_t,
        cinfo: *const sk_imageinfo_t,
        addr: *const ::std::os::raw::c_void,
        rowBytes: usize,
    );
    pub fn sk_pixmap_set_colorspace(cpixmap: *mut sk_pixmap_t, colorspace: *mut sk_colorspace_t);
    pub fn sk_pixmap_extract_subset(
        cpixmap: *const sk_pixmap_t,
        result: *mut sk_pixmap_t,
        subset: *const sk_irect_t,
    ) -> bool;
    pub fn sk_pixmap_get_info(cpixmap: *const sk_pixmap_t, cinfo: *mut sk_imageinfo_t);
    pub fn sk_pixmap_get_row_bytes(cpixmap: *const sk_pixmap_t) -> usize;
    pub fn sk_pixmap_get_colorspace(cpixmap: *const sk_pixmap_t) -> *mut sk_colorspace_t;
    pub fn sk_pixmap_compute_is_opaque(cpixmap: *const sk_pixmap_t) -> bool;
    pub fn sk_pixmap_get_pixel_color(
        cpixmap: *const sk_pixmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> sk_color_t;
    pub fn sk_pixmap_get_pixel_color4f(
        cpixmap: *const sk_pixmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: *mut sk_color4f_t,
    );
    pub fn sk_pixmap_get_pixel_alphaf(
        cpixmap: *const sk_pixmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
    pub fn sk_pixmap_get_writable_addr(cpixmap: *const sk_pixmap_t) -> *mut ::std::os::raw::c_void;
    pub fn sk_pixmap_get_writeable_addr_with_xy(
        cpixmap: *const sk_pixmap_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn sk_pixmap_read_pixels(
        cpixmap: *const sk_pixmap_t,
        dstInfo: *const sk_imageinfo_t,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_pixmap_scale_pixels(
        cpixmap: *const sk_pixmap_t,
        dst: *const sk_pixmap_t,
        sampling: *const sk_sampling_options_t,
    ) -> bool;
    pub fn sk_pixmap_erase_color(
        cpixmap: *const sk_pixmap_t,
        color: sk_color_t,
        subset: *const sk_irect_t,
    ) -> bool;
    pub fn sk_pixmap_erase_color4f(
        cpixmap: *const sk_pixmap_t,
        color: *const sk_color4f_t,
        subset: *const sk_irect_t,
    ) -> bool;
    pub fn sk_webpencoder_encode(
        dst: *mut sk_wstream_t,
        src: *const sk_pixmap_t,
        options: *const sk_webpencoder_options_t,
    ) -> bool;
    pub fn sk_jpegencoder_encode(
        dst: *mut sk_wstream_t,
        src: *const sk_pixmap_t,
        options: *const sk_jpegencoder_options_t,
    ) -> bool;
    pub fn sk_pngencoder_encode(
        dst: *mut sk_wstream_t,
        src: *const sk_pixmap_t,
        options: *const sk_pngencoder_options_t,
    ) -> bool;
    pub fn sk_swizzle_swap_rb(dest: *mut u32, src: *const u32, count: ::std::os::raw::c_int);
    pub fn sk_color_unpremultiply(pmcolor: sk_pmcolor_t) -> sk_color_t;
    pub fn sk_color_premultiply(color: sk_color_t) -> sk_pmcolor_t;
    pub fn sk_color_unpremultiply_array(
        pmcolors: *const sk_pmcolor_t,
        size: ::std::os::raw::c_int,
        colors: *mut sk_color_t,
    );
    pub fn sk_color_premultiply_array(
        colors: *const sk_color_t,
        size: ::std::os::raw::c_int,
        pmcolors: *mut sk_pmcolor_t,
    );
    pub fn sk_color_get_bit_shift(
        a: *mut ::std::os::raw::c_int,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
    );
    pub fn sk_region_new() -> *mut sk_region_t;
    pub fn sk_region_delete(r: *mut sk_region_t);
    pub fn sk_region_is_empty(r: *const sk_region_t) -> bool;
    pub fn sk_region_is_rect(r: *const sk_region_t) -> bool;
    pub fn sk_region_is_complex(r: *const sk_region_t) -> bool;
    pub fn sk_region_get_bounds(r: *const sk_region_t, rect: *mut sk_irect_t);
    pub fn sk_region_get_boundary_path(r: *const sk_region_t, path: *mut sk_path_t) -> bool;
    pub fn sk_region_set_empty(r: *mut sk_region_t) -> bool;
    pub fn sk_region_set_rect(r: *mut sk_region_t, rect: *const sk_irect_t) -> bool;
    pub fn sk_region_set_rects(
        r: *mut sk_region_t,
        rects: *const sk_irect_t,
        count: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_region_set_region(r: *mut sk_region_t, region: *const sk_region_t) -> bool;
    pub fn sk_region_set_path(
        r: *mut sk_region_t,
        t: *const sk_path_t,
        clip: *const sk_region_t,
    ) -> bool;
    pub fn sk_region_intersects_rect(r: *const sk_region_t, rect: *const sk_irect_t) -> bool;
    pub fn sk_region_intersects(r: *const sk_region_t, src: *const sk_region_t) -> bool;
    pub fn sk_region_contains_point(
        r: *const sk_region_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_region_contains_rect(r: *const sk_region_t, rect: *const sk_irect_t) -> bool;
    pub fn sk_region_contains(r: *const sk_region_t, region: *const sk_region_t) -> bool;
    pub fn sk_region_quick_contains(r: *const sk_region_t, rect: *const sk_irect_t) -> bool;
    pub fn sk_region_quick_reject_rect(r: *const sk_region_t, rect: *const sk_irect_t) -> bool;
    pub fn sk_region_quick_reject(r: *const sk_region_t, region: *const sk_region_t) -> bool;
    pub fn sk_region_translate(
        r: *mut sk_region_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
    pub fn sk_region_op_rect(
        r: *mut sk_region_t,
        rect: *const sk_irect_t,
        op: sk_region_op_t,
    ) -> bool;
    pub fn sk_region_op(
        r: *mut sk_region_t,
        region: *const sk_region_t,
        op: sk_region_op_t,
    ) -> bool;
    pub fn sk_region_iterator_new(region: *const sk_region_t) -> *mut sk_region_iterator_t;
    pub fn sk_region_iterator_delete(iter: *mut sk_region_iterator_t);
    pub fn sk_region_iterator_rewind(iter: *mut sk_region_iterator_t) -> bool;
    pub fn sk_region_iterator_done(iter: *const sk_region_iterator_t) -> bool;
    pub fn sk_region_iterator_next(iter: *mut sk_region_iterator_t);
    pub fn sk_region_iterator_rect(iter: *const sk_region_iterator_t, rect: *mut sk_irect_t);
    pub fn sk_region_cliperator_new(
        region: *const sk_region_t,
        clip: *const sk_irect_t,
    ) -> *mut sk_region_cliperator_t;
    pub fn sk_region_cliperator_delete(iter: *mut sk_region_cliperator_t);
    pub fn sk_region_cliperator_done(iter: *mut sk_region_cliperator_t) -> bool;
    pub fn sk_region_cliperator_next(iter: *mut sk_region_cliperator_t);
    pub fn sk_region_cliperator_rect(iter: *const sk_region_cliperator_t, rect: *mut sk_irect_t);
    pub fn sk_region_spanerator_new(
        region: *const sk_region_t,
        y: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    ) -> *mut sk_region_spanerator_t;
    pub fn sk_region_spanerator_delete(iter: *mut sk_region_spanerator_t);
    pub fn sk_region_spanerator_next(
        iter: *mut sk_region_spanerator_t,
        left: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_rrect_new() -> *mut sk_rrect_t;
    pub fn sk_rrect_new_copy(rrect: *const sk_rrect_t) -> *mut sk_rrect_t;
    pub fn sk_rrect_delete(rrect: *const sk_rrect_t);
    pub fn sk_rrect_get_type(rrect: *const sk_rrect_t) -> sk_rrect_type_t;
    pub fn sk_rrect_get_rect(rrect: *const sk_rrect_t, rect: *mut sk_rect_t);
    pub fn sk_rrect_get_radii(
        rrect: *const sk_rrect_t,
        corner: sk_rrect_corner_t,
        radii: *mut sk_vector_t,
    );
    pub fn sk_rrect_get_width(rrect: *const sk_rrect_t) -> f32;
    pub fn sk_rrect_get_height(rrect: *const sk_rrect_t) -> f32;
    pub fn sk_rrect_set_empty(rrect: *mut sk_rrect_t);
    pub fn sk_rrect_set_rect(rrect: *mut sk_rrect_t, rect: *const sk_rect_t);
    pub fn sk_rrect_set_oval(rrect: *mut sk_rrect_t, rect: *const sk_rect_t);
    pub fn sk_rrect_set_rect_xy(
        rrect: *mut sk_rrect_t,
        rect: *const sk_rect_t,
        xRad: f32,
        yRad: f32,
    );
    pub fn sk_rrect_set_nine_patch(
        rrect: *mut sk_rrect_t,
        rect: *const sk_rect_t,
        leftRad: f32,
        topRad: f32,
        rightRad: f32,
        bottomRad: f32,
    );
    pub fn sk_rrect_set_rect_radii(
        rrect: *mut sk_rrect_t,
        rect: *const sk_rect_t,
        radii: *const sk_vector_t,
    );
    pub fn sk_rrect_inset(rrect: *mut sk_rrect_t, dx: f32, dy: f32);
    pub fn sk_rrect_outset(rrect: *mut sk_rrect_t, dx: f32, dy: f32);
    pub fn sk_rrect_offset(rrect: *mut sk_rrect_t, dx: f32, dy: f32);
    pub fn sk_rrect_contains(rrect: *const sk_rrect_t, rect: *const sk_rect_t) -> bool;
    pub fn sk_rrect_is_valid(rrect: *const sk_rrect_t) -> bool;
    pub fn sk_rrect_transform(
        rrect: *mut sk_rrect_t,
        matrix: *const sk_matrix_t,
        dest: *mut sk_rrect_t,
    ) -> bool;
    pub fn sk_runtimeeffect_make_for_color_filter(
        sksl: *mut sk_string_t,
        error: *mut sk_string_t,
    ) -> *mut sk_runtimeeffect_t;
    pub fn sk_runtimeeffect_make_for_shader(
        sksl: *mut sk_string_t,
        error: *mut sk_string_t,
    ) -> *mut sk_runtimeeffect_t;
    pub fn sk_runtimeeffect_unref(effect: *mut sk_runtimeeffect_t);
    pub fn sk_runtimeeffect_make_shader(
        effect: *mut sk_runtimeeffect_t,
        uniforms: *mut sk_data_t,
        children: *mut *mut sk_flattenable_t,
        childCount: usize,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_runtimeeffect_make_color_filter(
        effect: *mut sk_runtimeeffect_t,
        uniforms: *mut sk_data_t,
        children: *mut *mut sk_flattenable_t,
        childCount: usize,
    ) -> *mut sk_colorfilter_t;
    pub fn sk_runtimeeffect_get_uniform_byte_size(effect: *const sk_runtimeeffect_t) -> usize;
    pub fn sk_runtimeeffect_get_uniforms_size(effect: *const sk_runtimeeffect_t) -> usize;
    pub fn sk_runtimeeffect_get_uniform_name(
        effect: *const sk_runtimeeffect_t,
        index: ::std::os::raw::c_int,
        name: *mut sk_string_t,
    );
    pub fn sk_runtimeeffect_get_uniform_from_index(
        effect: *const sk_runtimeeffect_t,
        index: ::std::os::raw::c_int,
        cuniform: *mut sk_runtimeeffect_uniform_t,
    );
    pub fn sk_runtimeeffect_get_uniform_from_name(
        effect: *const sk_runtimeeffect_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
        cuniform: *mut sk_runtimeeffect_uniform_t,
    );
    pub fn sk_runtimeeffect_get_children_size(effect: *const sk_runtimeeffect_t) -> usize;
    pub fn sk_runtimeeffect_get_child_name(
        effect: *const sk_runtimeeffect_t,
        index: ::std::os::raw::c_int,
        name: *mut sk_string_t,
    );
    pub fn sk_runtimeeffect_get_child_from_index(
        effect: *const sk_runtimeeffect_t,
        index: ::std::os::raw::c_int,
        cchild: *mut sk_runtimeeffect_child_t,
    );
    pub fn sk_runtimeeffect_get_child_from_name(
        effect: *const sk_runtimeeffect_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
        cchild: *mut sk_runtimeeffect_child_t,
    );
    pub fn sk_shader_ref(shader: *mut sk_shader_t);
    pub fn sk_shader_unref(shader: *mut sk_shader_t);
    pub fn sk_shader_with_local_matrix(
        shader: *const sk_shader_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_with_color_filter(
        shader: *const sk_shader_t,
        filter: *const sk_colorfilter_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_empty() -> *mut sk_shader_t;
    pub fn sk_shader_new_color(color: sk_color_t) -> *mut sk_shader_t;
    pub fn sk_shader_new_color4f(
        color: *const sk_color4f_t,
        colorspace: *const sk_colorspace_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_blend(
        mode: sk_blendmode_t,
        dst: *const sk_shader_t,
        src: *const sk_shader_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_linear_gradient(
        points: *const sk_point_t,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_linear_gradient_color4f(
        points: *const sk_point_t,
        colors: *const sk_color4f_t,
        colorspace: *const sk_colorspace_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_radial_gradient(
        center: *const sk_point_t,
        radius: f32,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_radial_gradient_color4f(
        center: *const sk_point_t,
        radius: f32,
        colors: *const sk_color4f_t,
        colorspace: *const sk_colorspace_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_sweep_gradient(
        center: *const sk_point_t,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        startAngle: f32,
        endAngle: f32,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_sweep_gradient_color4f(
        center: *const sk_point_t,
        colors: *const sk_color4f_t,
        colorspace: *const sk_colorspace_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        startAngle: f32,
        endAngle: f32,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_two_point_conical_gradient(
        start: *const sk_point_t,
        startRadius: f32,
        end: *const sk_point_t,
        endRadius: f32,
        colors: *const sk_color_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_two_point_conical_gradient_color4f(
        start: *const sk_point_t,
        startRadius: f32,
        end: *const sk_point_t,
        endRadius: f32,
        colors: *const sk_color4f_t,
        colorspace: *const sk_colorspace_t,
        colorPos: *const f32,
        colorCount: ::std::os::raw::c_int,
        tileMode: sk_shader_tilemode_t,
        localMatrix: *const sk_matrix_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_perlin_noise_fractal_noise(
        baseFrequencyX: f32,
        baseFrequencyY: f32,
        numOctaves: ::std::os::raw::c_int,
        seed: f32,
        tileSize: *const sk_isize_t,
    ) -> *mut sk_shader_t;
    pub fn sk_shader_new_perlin_noise_turbulence(
        baseFrequencyX: f32,
        baseFrequencyY: f32,
        numOctaves: ::std::os::raw::c_int,
        seed: f32,
        tileSize: *const sk_isize_t,
    ) -> *mut sk_shader_t;
    pub fn sk_stream_asset_destroy(cstream: *mut sk_stream_asset_t);
    pub fn sk_filestream_new(path: *const ::std::os::raw::c_char) -> *mut sk_stream_filestream_t;
    pub fn sk_filestream_destroy(cstream: *mut sk_stream_filestream_t);
    pub fn sk_filestream_is_valid(cstream: *mut sk_stream_filestream_t) -> bool;
    pub fn sk_memorystream_new() -> *mut sk_stream_memorystream_t;
    pub fn sk_memorystream_new_with_length(length: usize) -> *mut sk_stream_memorystream_t;
    pub fn sk_memorystream_new_with_data(
        data: *const ::std::os::raw::c_void,
        length: usize,
        copyData: bool,
    ) -> *mut sk_stream_memorystream_t;
    pub fn sk_memorystream_new_with_skdata(data: *mut sk_data_t) -> *mut sk_stream_memorystream_t;
    pub fn sk_memorystream_set_memory(
        cmemorystream: *mut sk_stream_memorystream_t,
        data: *const ::std::os::raw::c_void,
        length: usize,
        copyData: bool,
    );
    pub fn sk_memorystream_destroy(cstream: *mut sk_stream_memorystream_t);
    pub fn sk_stream_read(
        cstream: *mut sk_stream_t,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
    pub fn sk_stream_peek(
        cstream: *mut sk_stream_t,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
    pub fn sk_stream_skip(cstream: *mut sk_stream_t, size: usize) -> usize;
    pub fn sk_stream_is_at_end(cstream: *mut sk_stream_t) -> bool;
    pub fn sk_stream_read_s8(cstream: *mut sk_stream_t, buffer: *mut i8) -> bool;
    pub fn sk_stream_read_s16(cstream: *mut sk_stream_t, buffer: *mut i16) -> bool;
    pub fn sk_stream_read_s32(cstream: *mut sk_stream_t, buffer: *mut i32) -> bool;
    pub fn sk_stream_read_u8(cstream: *mut sk_stream_t, buffer: *mut u8) -> bool;
    pub fn sk_stream_read_u16(cstream: *mut sk_stream_t, buffer: *mut u16) -> bool;
    pub fn sk_stream_read_u32(cstream: *mut sk_stream_t, buffer: *mut u32) -> bool;
    pub fn sk_stream_read_bool(cstream: *mut sk_stream_t, buffer: *mut bool) -> bool;
    pub fn sk_stream_rewind(cstream: *mut sk_stream_t) -> bool;
    pub fn sk_stream_has_position(cstream: *mut sk_stream_t) -> bool;
    pub fn sk_stream_get_position(cstream: *mut sk_stream_t) -> usize;
    pub fn sk_stream_seek(cstream: *mut sk_stream_t, position: usize) -> bool;
    pub fn sk_stream_move(cstream: *mut sk_stream_t, offset: ::std::os::raw::c_long) -> bool;
    pub fn sk_stream_has_length(cstream: *mut sk_stream_t) -> bool;
    pub fn sk_stream_get_length(cstream: *mut sk_stream_t) -> usize;
    pub fn sk_stream_get_memory_base(cstream: *mut sk_stream_t) -> *const ::std::os::raw::c_void;
    pub fn sk_stream_fork(cstream: *mut sk_stream_t) -> *mut sk_stream_t;
    pub fn sk_stream_duplicate(cstream: *mut sk_stream_t) -> *mut sk_stream_t;
    pub fn sk_stream_destroy(cstream: *mut sk_stream_t);
    pub fn sk_filewstream_new(path: *const ::std::os::raw::c_char) -> *mut sk_wstream_filestream_t;
    pub fn sk_filewstream_destroy(cstream: *mut sk_wstream_filestream_t);
    pub fn sk_filewstream_is_valid(cstream: *mut sk_wstream_filestream_t) -> bool;
    pub fn sk_dynamicmemorywstream_new() -> *mut sk_wstream_dynamicmemorystream_t;
    pub fn sk_dynamicmemorywstream_detach_as_stream(
        cstream: *mut sk_wstream_dynamicmemorystream_t,
    ) -> *mut sk_stream_asset_t;
    pub fn sk_dynamicmemorywstream_detach_as_data(
        cstream: *mut sk_wstream_dynamicmemorystream_t,
    ) -> *mut sk_data_t;
    pub fn sk_dynamicmemorywstream_copy_to(
        cstream: *mut sk_wstream_dynamicmemorystream_t,
        data: *mut ::std::os::raw::c_void,
    );
    pub fn sk_dynamicmemorywstream_write_to_stream(
        cstream: *mut sk_wstream_dynamicmemorystream_t,
        dst: *mut sk_wstream_t,
    ) -> bool;
    pub fn sk_dynamicmemorywstream_destroy(cstream: *mut sk_wstream_dynamicmemorystream_t);
    pub fn sk_wstream_write(
        cstream: *mut sk_wstream_t,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
    pub fn sk_wstream_newline(cstream: *mut sk_wstream_t) -> bool;
    pub fn sk_wstream_flush(cstream: *mut sk_wstream_t);
    pub fn sk_wstream_bytes_written(cstream: *mut sk_wstream_t) -> usize;
    pub fn sk_wstream_write_8(cstream: *mut sk_wstream_t, value: u8) -> bool;
    pub fn sk_wstream_write_16(cstream: *mut sk_wstream_t, value: u16) -> bool;
    pub fn sk_wstream_write_32(cstream: *mut sk_wstream_t, value: u32) -> bool;
    pub fn sk_wstream_write_text(
        cstream: *mut sk_wstream_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn sk_wstream_write_dec_as_text(cstream: *mut sk_wstream_t, value: i32) -> bool;
    pub fn sk_wstream_write_bigdec_as_text(
        cstream: *mut sk_wstream_t,
        value: i64,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_wstream_write_hex_as_text(
        cstream: *mut sk_wstream_t,
        value: u32,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_wstream_write_scalar_as_text(cstream: *mut sk_wstream_t, value: f32) -> bool;
    pub fn sk_wstream_write_bool(cstream: *mut sk_wstream_t, value: bool) -> bool;
    pub fn sk_wstream_write_scalar(cstream: *mut sk_wstream_t, value: f32) -> bool;
    pub fn sk_wstream_write_packed_uint(cstream: *mut sk_wstream_t, value: usize) -> bool;
    pub fn sk_wstream_write_stream(
        cstream: *mut sk_wstream_t,
        input: *mut sk_stream_t,
        length: usize,
    ) -> bool;
    pub fn sk_wstream_get_size_of_packed_uint(value: usize) -> ::std::os::raw::c_int;
    pub fn sk_string_new_empty() -> *mut sk_string_t;
    pub fn sk_string_new_with_copy(
        src: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut sk_string_t;
    pub fn sk_string_destructor(arg1: *const sk_string_t);
    pub fn sk_string_get_size(arg1: *const sk_string_t) -> usize;
    pub fn sk_string_get_c_str(arg1: *const sk_string_t) -> *const ::std::os::raw::c_char;
    pub fn sk_surface_new_null(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_raster(
        arg1: *const sk_imageinfo_t,
        rowBytes: usize,
        arg2: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_raster_direct(
        arg1: *const sk_imageinfo_t,
        pixels: *mut ::std::os::raw::c_void,
        rowBytes: usize,
        releaseProc: sk_surface_raster_release_proc,
        context: *mut ::std::os::raw::c_void,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_backend_texture(
        context: *mut gr_recording_context_t,
        texture: *const gr_backendtexture_t,
        origin: gr_surfaceorigin_t,
        samples: ::std::os::raw::c_int,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_backend_render_target(
        context: *mut gr_recording_context_t,
        target: *const gr_backendrendertarget_t,
        origin: gr_surfaceorigin_t,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_render_target(
        context: *mut gr_recording_context_t,
        budgeted: bool,
        cinfo: *const sk_imageinfo_t,
        sampleCount: ::std::os::raw::c_int,
        origin: gr_surfaceorigin_t,
        props: *const sk_surfaceprops_t,
        shouldCreateWithMips: bool,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_metal_layer(
        context: *mut gr_recording_context_t,
        layer: *const ::std::os::raw::c_void,
        origin: gr_surfaceorigin_t,
        sampleCount: ::std::os::raw::c_int,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
        drawable: *mut *const ::std::os::raw::c_void,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_new_metal_view(
        context: *mut gr_recording_context_t,
        mtkView: *const ::std::os::raw::c_void,
        origin: gr_surfaceorigin_t,
        sampleCount: ::std::os::raw::c_int,
        colorType: sk_colortype_t,
        colorspace: *mut sk_colorspace_t,
        props: *const sk_surfaceprops_t,
    ) -> *mut sk_surface_t;
    pub fn sk_surface_unref(arg1: *mut sk_surface_t);
    pub fn sk_surface_get_canvas(arg1: *mut sk_surface_t) -> *mut sk_canvas_t;
    pub fn sk_surface_new_image_snapshot(arg1: *mut sk_surface_t) -> *mut sk_image_t;
    pub fn sk_surface_new_image_snapshot_with_crop(
        surface: *mut sk_surface_t,
        bounds: *const sk_irect_t,
    ) -> *mut sk_image_t;
    pub fn sk_surface_draw(
        surface: *mut sk_surface_t,
        canvas: *mut sk_canvas_t,
        x: f32,
        y: f32,
        paint: *const sk_paint_t,
    );
    pub fn sk_surface_peek_pixels(surface: *mut sk_surface_t, pixmap: *mut sk_pixmap_t) -> bool;
    pub fn sk_surface_read_pixels(
        surface: *mut sk_surface_t,
        dstInfo: *mut sk_imageinfo_t,
        dstPixels: *mut ::std::os::raw::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
    pub fn sk_surface_get_props(surface: *mut sk_surface_t) -> *const sk_surfaceprops_t;
    pub fn sk_surface_get_recording_context(
        surface: *mut sk_surface_t,
    ) -> *mut gr_recording_context_t;
    pub fn sk_surfaceprops_new(flags: u32, geometry: sk_pixelgeometry_t) -> *mut sk_surfaceprops_t;
    pub fn sk_surfaceprops_delete(props: *mut sk_surfaceprops_t);
    pub fn sk_surfaceprops_get_flags(props: *mut sk_surfaceprops_t) -> u32;
    pub fn sk_surfaceprops_get_pixel_geometry(props: *mut sk_surfaceprops_t) -> sk_pixelgeometry_t;
    pub fn sk_svgcanvas_create_with_stream(
        bounds: *const sk_rect_t,
        stream: *mut sk_wstream_t,
    ) -> *mut sk_canvas_t;
    pub fn sk_textblob_ref(blob: *const sk_textblob_t);
    pub fn sk_textblob_unref(blob: *const sk_textblob_t);
    pub fn sk_textblob_get_unique_id(blob: *const sk_textblob_t) -> u32;
    pub fn sk_textblob_get_bounds(blob: *const sk_textblob_t, bounds: *mut sk_rect_t);
    pub fn sk_textblob_get_intercepts(
        blob: *const sk_textblob_t,
        bounds: *const f32,
        intervals: *mut f32,
        paint: *const sk_paint_t,
    ) -> ::std::os::raw::c_int;
    pub fn sk_textblob_builder_new() -> *mut sk_textblob_builder_t;
    pub fn sk_textblob_builder_delete(builder: *mut sk_textblob_builder_t);
    pub fn sk_textblob_builder_make(builder: *mut sk_textblob_builder_t) -> *mut sk_textblob_t;
    pub fn sk_textblob_builder_alloc_run(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        x: f32,
        y: f32,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_pos_h(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        y: f32,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_pos(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_rsxform(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_text(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        x: f32,
        y: f32,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_text_pos_h(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        y: f32,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_text_pos(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_textblob_builder_alloc_run_text_rsxform(
        builder: *mut sk_textblob_builder_t,
        font: *const sk_font_t,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const sk_rect_t,
        runbuffer: *mut sk_textblob_builder_runbuffer_t,
    );
    pub fn sk_typeface_unref(typeface: *mut sk_typeface_t);
    pub fn sk_typeface_get_fontstyle(typeface: *const sk_typeface_t) -> *mut sk_fontstyle_t;
    pub fn sk_typeface_get_font_weight(typeface: *const sk_typeface_t) -> ::std::os::raw::c_int;
    pub fn sk_typeface_get_font_width(typeface: *const sk_typeface_t) -> ::std::os::raw::c_int;
    pub fn sk_typeface_get_font_slant(typeface: *const sk_typeface_t) -> sk_font_style_slant_t;
    pub fn sk_typeface_is_fixed_pitch(typeface: *const sk_typeface_t) -> bool;
    pub fn sk_typeface_unichars_to_glyphs(
        typeface: *const sk_typeface_t,
        unichars: *const i32,
        count: ::std::os::raw::c_int,
        glyphs: *mut u16,
    );
    pub fn sk_typeface_unichar_to_glyph(typeface: *const sk_typeface_t, unichar: i32) -> u16;
    pub fn sk_typeface_count_glyphs(typeface: *const sk_typeface_t) -> ::std::os::raw::c_int;
    pub fn sk_typeface_count_tables(typeface: *const sk_typeface_t) -> ::std::os::raw::c_int;
    pub fn sk_typeface_get_table_tags(
        typeface: *const sk_typeface_t,
        tags: *mut sk_font_table_tag_t,
    ) -> ::std::os::raw::c_int;
    pub fn sk_typeface_get_table_size(
        typeface: *const sk_typeface_t,
        tag: sk_font_table_tag_t,
    ) -> usize;
    pub fn sk_typeface_get_table_data(
        typeface: *const sk_typeface_t,
        tag: sk_font_table_tag_t,
        offset: usize,
        length: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
    pub fn sk_typeface_copy_table_data(
        typeface: *const sk_typeface_t,
        tag: sk_font_table_tag_t,
    ) -> *mut sk_data_t;
    pub fn sk_typeface_get_units_per_em(typeface: *const sk_typeface_t) -> ::std::os::raw::c_int;
    pub fn sk_typeface_get_kerning_pair_adjustments(
        typeface: *const sk_typeface_t,
        glyphs: *const u16,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool;
    pub fn sk_typeface_get_family_name(typeface: *const sk_typeface_t) -> *mut sk_string_t;
    pub fn sk_typeface_open_stream(
        typeface: *const sk_typeface_t,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> *mut sk_stream_asset_t;
    pub fn sk_fontmgr_create_custom_dir(arg1: *const ::std::os::raw::c_char) -> *mut sk_fontmgr_t;
    pub fn sk_fontmgr_create_custom_data(
        datas: *mut *const sk_data_t,
        datas_count: usize,
    ) -> *mut sk_fontmgr_t;
    pub fn sk_fontmgr_ref_empty() -> *mut sk_fontmgr_t;
    pub fn sk_fontmgr_unref(arg1: *mut sk_fontmgr_t);
    pub fn sk_fontmgr_count_families(arg1: *mut sk_fontmgr_t) -> ::std::os::raw::c_int;
    pub fn sk_fontmgr_get_family_name(
        arg1: *mut sk_fontmgr_t,
        index: ::std::os::raw::c_int,
        familyName: *mut sk_string_t,
    );
    pub fn sk_fontmgr_create_styleset(
        arg1: *mut sk_fontmgr_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_fontstyleset_t;
    pub fn sk_fontmgr_match_family(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut sk_fontstyleset_t;
    pub fn sk_fontmgr_match_family_style(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontmgr_match_family_style_character(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
        style: *mut sk_fontstyle_t,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: i32,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontmgr_create_from_data(
        arg1: *mut sk_fontmgr_t,
        data: *mut sk_data_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontmgr_create_from_stream(
        arg1: *mut sk_fontmgr_t,
        stream: *mut sk_stream_asset_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontmgr_create_from_file(
        arg1: *mut sk_fontmgr_t,
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontmgr_typeface_create_from_name(
        arg1: *mut sk_fontmgr_t,
        familyName: *const ::std::os::raw::c_char,
        style: *const sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontstyle_new(
        weight: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        slant: sk_font_style_slant_t,
    ) -> *mut sk_fontstyle_t;
    pub fn sk_fontstyle_delete(fs: *mut sk_fontstyle_t);
    pub fn sk_fontstyle_get_weight(fs: *const sk_fontstyle_t) -> ::std::os::raw::c_int;
    pub fn sk_fontstyle_get_width(fs: *const sk_fontstyle_t) -> ::std::os::raw::c_int;
    pub fn sk_fontstyle_get_slant(fs: *const sk_fontstyle_t) -> sk_font_style_slant_t;
    pub fn sk_fontstyleset_create_empty() -> *mut sk_fontstyleset_t;
    pub fn sk_fontstyleset_unref(fss: *mut sk_fontstyleset_t);
    pub fn sk_fontstyleset_get_count(fss: *mut sk_fontstyleset_t) -> ::std::os::raw::c_int;
    pub fn sk_fontstyleset_get_style(
        fss: *mut sk_fontstyleset_t,
        index: ::std::os::raw::c_int,
        fs: *mut sk_fontstyle_t,
        style: *mut sk_string_t,
    );
    pub fn sk_fontstyleset_create_typeface(
        fss: *mut sk_fontstyleset_t,
        index: ::std::os::raw::c_int,
    ) -> *mut sk_typeface_t;
    pub fn sk_fontstyleset_match_style(
        fss: *mut sk_fontstyleset_t,
        style: *mut sk_fontstyle_t,
    ) -> *mut sk_typeface_t;
    pub fn sk_icu_set_icudtl_dat(arg1: *mut ::std::os::raw::c_void) -> bool;
    pub fn sk_vertices_unref(cvertices: *mut sk_vertices_t);
    pub fn sk_vertices_ref(cvertices: *mut sk_vertices_t);
    pub fn sk_vertices_make_copy(
        vmode: sk_vertices_vertex_mode_t,
        vertexCount: ::std::os::raw::c_int,
        positions: *const sk_point_t,
        texs: *const sk_point_t,
        colors: *const sk_color_t,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> *mut sk_vertices_t;
    pub fn skottie_animation_keepalive();
    pub fn skottie_animation_make_from_string(
        data: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut skottie_animation_t;
    pub fn skottie_animation_make_from_data(
        data: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut skottie_animation_t;
    pub fn skottie_animation_make_from_stream(stream: *mut sk_stream_t)
        -> *mut skottie_animation_t;
    pub fn skottie_animation_make_from_file(
        path: *const ::std::os::raw::c_char,
    ) -> *mut skottie_animation_t;
    pub fn skottie_animation_ref(instance: *mut skottie_animation_t);
    pub fn skottie_animation_unref(instance: *mut skottie_animation_t);
    pub fn skottie_animation_delete(instance: *mut skottie_animation_t);
    pub fn skottie_animation_render(
        instance: *mut skottie_animation_t,
        canvas: *mut sk_canvas_t,
        dst: *mut sk_rect_t,
    );
    pub fn skottie_animation_render_with_flags(
        instance: *mut skottie_animation_t,
        canvas: *mut sk_canvas_t,
        dst: *mut sk_rect_t,
        flags: skottie_animation_renderflags_t,
    );
    pub fn skottie_animation_seek(
        instance: *mut skottie_animation_t,
        t: f32,
        ic: *mut sksg_invalidation_controller_t,
    );
    pub fn skottie_animation_seek_frame(
        instance: *mut skottie_animation_t,
        t: f32,
        ic: *mut sksg_invalidation_controller_t,
    );
    pub fn skottie_animation_seek_frame_time(
        instance: *mut skottie_animation_t,
        t: f32,
        ic: *mut sksg_invalidation_controller_t,
    );
    pub fn skottie_animation_get_duration(instance: *mut skottie_animation_t) -> f64;
    pub fn skottie_animation_get_fps(instance: *mut skottie_animation_t) -> f64;
    pub fn skottie_animation_get_in_point(instance: *mut skottie_animation_t) -> f64;
    pub fn skottie_animation_get_out_point(instance: *mut skottie_animation_t) -> f64;
    pub fn skottie_animation_get_version(
        instance: *mut skottie_animation_t,
        version: *mut sk_string_t,
    );
    pub fn skottie_animation_get_size(instance: *mut skottie_animation_t, size: *mut sk_size_t);
    pub fn sksg_invalidation_controller_new() -> *mut sksg_invalidation_controller_t;
    pub fn sksg_invalidation_controller_delete(instance: *mut sksg_invalidation_controller_t);
    pub fn sksg_invalidation_controller_inval(
        instance: *mut sksg_invalidation_controller_t,
        rect: *mut sk_rect_t,
        matrix: *mut sk_matrix_t,
    );
    pub fn sksg_invalidation_controller_get_bounds(
        instance: *mut sksg_invalidation_controller_t,
        bounds: *mut sk_rect_t,
    );
    pub fn sksg_invalidation_controller_begin(instance: *mut sksg_invalidation_controller_t);
    pub fn sksg_invalidation_controller_end(instance: *mut sksg_invalidation_controller_t);
    pub fn sksg_invalidation_controller_reset(instance: *mut sksg_invalidation_controller_t);
    pub fn check_skiac() -> ::std::os::raw::c_int;
}
